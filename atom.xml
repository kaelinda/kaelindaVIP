<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Kaelinda]]></title>
  <link href="http://kaelinda.top/atom.xml" rel="self"/>
  <link href="http://kaelinda.top/"/>
  <updated>2021-10-12T11:39:04+08:00</updated>
  <id>http://kaelinda.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[音视频学习笔记 1]]></title>
    <link href="http://kaelinda.top/16340038102685.html"/>
    
    <updated>2021-10-12T09:56:50+08:00</updated>
    <id>http://kaelinda.top/16340038102685.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>音视频概念</h2>
<h3><a id="%E5%A3%B0%E9%9F%B3%E7%9A%84%E7%89%A9%E7%90%86%E6%80%A7%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声音的物理性质</h3>
<ul>
<li>
<p>声波三要素：频率、振幅、波形</p>
</li>
<li>
<p>人耳听到的频率范围 20Hz-20KHz</p>
</li>
<li>
<p>声音在空气中的传播速度 340m/s、蒸馏水中1497m/s、铁棒5200m/s</p>
</li>
<li>
<p>一般声音的采样频率为 44.1KHz---&gt; 一秒钟采样44100次，这样 超过人耳听到的最大频率--20KHz的频率也能被数字化</p>
</li>
<li>
<p>音频的裸数据格式 脉冲编码调制  PCM （Pluse Code Modulation）</p>
</li>
<li>
<p>PCM 相关概念：</p>
<ul>
<li>量化格式(sampleFormate):有的地方称作 <strong>位深度</strong>，这个描述的是一个采样的大小，一般为2字节</li>
<li>采样频率(sampleRate)：一般为44.1kHz</li>
<li>声道数(channel):声道数通常为 2 声道</li>
</ul>
</li>
</ul>
<!--more-->
<blockquote>
<p>一般CD的音质描述：量化格式为16比特（2字节），采样频率44100Hz,声道数2。</p>
</blockquote>
<p>声音格式我们可以用<strong>数据比特率</strong>来描述其大小：每秒占用空间大小。</p>
<blockquote>
<p>44100 * 16 * 2 = 1378.125kbps</p>
</blockquote>
<p>一分钟里这种音质的CD占据多大存储空间？</p>
<blockquote>
<p>1378.125 * 60 / 8 / 1024 = 10.09MB</p>
</blockquote>
<p>量化格式如果更精确，每一个采样所携带的信息就越多，占用的存储空间就会越大，能描述的声音细节就越精细。</p>
<ul>
<li>分贝：是描述声音强度的单位。</li>
</ul>
<h3><a id="%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>音频编码</h3>
<p>音频压缩编码的指标：压缩比，通常小于1，否则就没有压缩的必要了。</p>
<p>音频压缩编码算法有：PCM、WAV、AAC、MP3、Ogg。</p>
<ul>
<li>WAV：音频质量好，大多数软件都支持，但是占用空间大；适合当做多媒体开发的中间文件，保存音乐、音效素材</li>
<li>MP3：不错的压缩比，LAME编码中高码率文件。音质在128Kbit/s 以上表现不错，压缩比高，大多数软件都支持。适合高比特率下对兼容性有要求的音乐欣赏。</li>
<li>AAC：包括LC-AAC、HE-AAC、HE-AAC v2,小于128Kbit/s表现优异。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center">LC-AAC</th>
<th style="text-align: center">HE-AAC</th>
<th style="text-align: center">HE-AAC v2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">中高码率&gt;80Kbit/s</td>
<td style="text-align: center">中低码率&lt;=80Kbit/s</td>
<td style="text-align: center">低码率&lt;48Kbit/s</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alfred 修改内置Terminal为Iterm2]]></title>
    <link href="http://kaelinda.top/16336595298050.html"/>
    
    <updated>2021-10-08T10:18:49+08:00</updated>
    <id>http://kaelinda.top/16336595298050.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<p><figure><img src="https://b3logfile.com/file/2019/09/image-cb8282c6.png?imageView2/2/interlace/1/format/webp" alt="" /></figure></p>
<pre><code class="language-plain_text">
-- This is v0.6 of the custom script for AlfredApp for iTerm 2.9+
-- Please see https://github.com/stuartcryan/custom-iterm-applescripts-for-alfred/
-- for the latest changes.

-- Please note, if you store the iTerm binary in any other location than the Applications Folder
-- please ensure you update the two locations below (in the format of : rather than / for folder dividers)
-- this gets around issues with AppleScript not handling things well if you have two iTerm binaries on your system... which can happen :D

on alfred_script(q)
	if application &quot;iTerm2&quot; is running or application &quot;iTerm&quot; is running then
		run script &quot;
			on run {q}
				tell application \&quot;:Applications:iTerm.app\&quot;
					activate
					try
						select first window
						set onlywindow to true
					on error
						create window with default profile
						select first window
						set onlywindow to true
					end try
					tell the first window
						if onlywindow is false then
							create tab with default profile
						end if
						tell current session to write text q
					end tell
				end tell
			end run
		&quot; with parameters {q}
	else
		run script &quot;
			on run {q}
				tell application \&quot;:Applications:iTerm.app\&quot;
					activate
					try
						select first window
					on error
						create window with default profile
						select first window
					end try
					tell the first window
						tell current session to write text q
					end tell
				end tell
			end run
		&quot; with parameters {q}
	end if
end alfred_script
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python环境安装]]></title>
    <link href="http://kaelinda.top/16325811812741.html"/>
    
    <updated>2021-09-25T22:46:21+08:00</updated>
    <id>http://kaelinda.top/16325811812741.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="pip%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>pip安装</h2>
<pre><code class="language-shell">sudo python -m ensurepip --upgrade
</code></pre>
<h2><a id="mac%E4%B8%8B%E5%A4%9A%E4%B8%AApython%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mac下多个Python版本管理</h2>
<p><a href="https://www.jianshu.com/p/3261976c10c2">参考文章</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Swift笔记】引用计数]]></title>
    <link href="http://kaelinda.top/15409691048860.html"/>
    
    <updated>2018-10-31T14:58:24+08:00</updated>
    <id>http://kaelinda.top/15409691048860.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<ul>
<li>和OC一样，Swift也是用ARC,也会有循环引用导致内存泄露</li>
<li>吧如果属性是可选类型，只能用weak修饰符避免循环引用。所引用对象被回收后改属性会被自动置为nil</li>
<li>如果属性不是可选类型，只能用无主引用（unowned）。所引用对象被回收后属性不会被置为nil，此时访问会导致运行时错误。类似OC中的unsafe_unretained修饰符</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中类（Class）和 结构体（Struct）]]></title>
    <link href="http://kaelinda.top/15402889434646.html"/>
    
    <updated>2018-10-23T18:02:23+08:00</updated>
    <id>http://kaelinda.top/15402889434646.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h2>
<p>共同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作使得可以通过下标语法来访问实例所包含的值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能</li>
</ul>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用（对象引用）结构体总是通过被复制的方式在代码中传递，不使用引用计数。</li>
</ul>
<h2><a id="%E9%80%90%E4%B8%80%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逐一对比</h2>
<h3><a id="%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义</h3>
<pre><code class="language-plain_text">//: ### 定义
class StudentClass{ }
struct StudebtStruct{ }
</code></pre>
<h3><a id="%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义存储属性</h3>
<pre><code class="language-plain_text">//: &gt; 类中定义的存储属性，如果不是可选类型，需要进行初始化；结构体则默认带有初始化方法
class StudentC01{
    var name: String!
}
struct StudebtS01{
    var name: String!
}
</code></pre>
<h3><a id="%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%87%BD%E6%95%B0function" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义属性函数function</h3>
<p>关于@objc 请参考 <a href="https://blog.csdn.net/qq_35612929/article/details/79563110">Swift 4.0学习之：@objc的使用</a></p>
<pre><code class="language-plain_text">//: ### 定义属性函数function
//: &gt; 类中可以使用 static 和 class两种修饰符；但是结构体中只能使用static修饰
class StudentC02{
    static var des:String = &quot;学生的类&quot;
    var name:String!
    @objc class func objc_describe()-&gt;String{
        return des
    }
    class func class_describe()-&gt;String{
        return des
    }
    static func static_describe()-&gt;String{
        return des
    }
}
struct StudentS02{
    static var des:String = &quot;学生的结构体&quot;
    var name:String!
    static func describe()-&gt;String{
        return &quot;这是一个定义学生的类&quot;
    }
}
</code></pre>
<h3><a id="%E6%89%A9%E5%B1%95%E4%B8%8B%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展下标</h3>
<pre><code class="language-plain_text">//: ### 扩展下标
//: &gt; *subscript*
class StudentC003{
    var names:[String] = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
    subscript (index:Int)-&gt;String?{
        get{
            if names.count &lt;= index{
                return nil
            }
            return names[index]
        }
    }
}
struct StudentS003{
    var names:[String] = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
    subscript (index:Int)-&gt;String?{
        get{
            if names.count &lt;= index{
                return nil
            }
            return names[index]
        }
    }
}
let sc003 = StudentC003()
sc003[1]// 2
let ss003 = StudentS003()
ss003[1]// 2
</code></pre>
<h3><a id="%E5%88%9D%E5%A7%8B%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化</h3>
<pre><code class="language-plain_text">//: ### 初始化
//: &gt; 结构体自带初始化方法（可以不写初始化方法）;
//: &gt; 类必须手写init方法，否则报错；
class StudentC004{
    var name:String
    init(name:String) {
        self.name = name
    }
}
struct StudentS004 {
    var name:String
    
}
let studentc004 = StudentC004(name: &quot;行走在北方&quot;)
let students004 = StudentS004(name: &quot;行走在北方&quot;)
</code></pre>
<h3><a id="%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BDextention" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展功能 Extention</h3>
<pre><code class="language-plain_text">//: ### 扩展功能 Extention
extension StudentC004{
    func discribe() -&gt; String {
        return &quot;student class:&quot;+self.name
    }
}
extension StudentS004{
    func discribe() -&gt; String {
        return &quot;student struct:&quot; + self.name
    }
}
</code></pre>
<h3><a id="%E5%AE%9E%E7%8E%B0%E5%8D%8F%E8%AE%AEprotocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现协议 protocol</h3>
<pre><code class="language-plain_text">//: ### 实现协议 protocol
//: * 定义协议
protocol Capacity {
    func draw()//协议方法
}
//: * 实现协议方法
class StudentC05:Capacity{
    internal func draw() {
        
    }
    var name:String
    init(name:String) {
        self.name = name
    }
}
struct StudentS05:Capacity{
    internal func draw() {
        
    }
    var name:String
}
</code></pre>
<h3><a id="mutating%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mutating 关键字的使用</h3>
<p>科普下:</p>
<ul>
<li>
<p>枚举和结构体都是值类型，Swift默认值类型的对象方法不能修改属性值,但是如果一定要修改 那就在函数前面添加mutating关键字</p>
</li>
<li>
<p>计算属性setter方法中不需要更改属性值的时候，不需要添加mutating关键字;</p>
</li>
<li>
<p>计算属性setter方法中更改属性值的时候，必须要添加mutating关键字</p>
</li>
</ul>
<pre><code class="language-plain_text">protocol Action{
    var myY:Int{
        mutating get
    }
}
struct Point {
    var x:Int
    var y:Int
    mutating func modifyX(x: Int){
        self.x = x
    }
    var myY:Int{
        mutating get {//getter方法前面添加mutating关键字
            self.y = self.y*2
            return y
        }
    }
}
class ActionClass {
    var name:String?
    init(name:String) {
        self.name = name
    }
    var myName:String? {
        get {// class 是对象类型 可以直接修改
            self.name = &quot;666 -&gt; :&quot; + self.name!
            return self.name
        }
    }
    
}
let actionclass = ActionClass(name: &quot;NB&quot;)
</code></pre>
<h2><a id="%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%88%E9%AA%8C%E8%AF%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断两个对象地址是否相同（验证 引用类型 和 值类型）</h2>
<pre><code class="language-plain_text">//: ### 判断两个对象地址是否相同
//: &gt; 类是引用类型；结构体是值类型；结构体不能通过=== 、！==类判断比较
//: &gt;
class StudentC07{
    var name: String
    init(name:String) {
        self.name = name
    }
}

let studentc071 = StudentC07(name: &quot;原始名字&quot;)
var studentc072 = studentc071
studentc071.name = &quot;新名字&quot;
print(&quot;student071:\(studentc071.name)\nstudent072:\(studentc072.name)&quot;)
if studentc071 === studentc072 {
    print(&quot;类是引用类型，最终指向同一块内存&quot;)
}
struct StudentS07{
    var name: String
    init(name:String) {
        self.name = name
    }
}
let students071 = StudentS07(name: &quot;结构体：原始名字&quot;)
var students072 = students071
students072.name = &quot;结构体：新名字&quot;
print(&quot;students071:\(students071.name)\nstudents072\(students072.name)&quot;)
</code></pre>
<h3><a id="deinit%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>deinit 释放资源</h3>
<p><a href="https://www.jianshu.com/p/9e725362eeb1">Swift中的deinit方法</a></p>
<pre><code class="language-plain_text">//: ### deinit 释放资源
//: &gt; 类有deinit方法；结构体中没有deinit方法。
class StudentC08{
    var name: String
    init(name:String) {
        self.name = name
    }
    deinit {
        //这里释放资源
    }
}
</code></pre>
<h3><a id="lazy%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%B1%9E%E6%80%A7%EF%BC%88%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lazy：延迟属性（懒加载）</h3>
<p>class 有延迟属性；struct没有延迟属性</p>
<pre><code class="language-plain_text">//: &gt; 延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标示一个延迟存储属性
class Importor{
    var fileName = &quot;data.txt&quot;
}
class DataManager{
    lazy var importor = Importor()
    var Data = [String]()
}
</code></pre>
<h3><a id="%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承</h3>
<pre><code class="language-plain_text">//: ### 继承
//: &gt; 类能继承；结构体不能继承。
class Person{
    var name:String
    init(name:String) {
        self.name = name
    }
}
class Student06: Person {
    var score : Float
    init(name: String, score: Float){
        self.score = score//先给父类中没有的属性赋值，再调用父类init方法
        super.init(name: name)
    }
}   
</code></pre>
<ul>
<li>
<p>继承之后 可重写父类方法/属性</p>
<ol>
<li>
<p>重写计算属性：只能增加功能不能减少功能——&gt;父类中有setter getter,那么子类重写计算属性 setter getter都必须要有。父类中只有setter  子类中可以在重写setter的同时增加getter</p>
</li>
<li>
<p>final 关键字可以让属性不被重写 或者 继承</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-plain_text">//: * 重写计算属性
//: * 重写对象方法
//: * 重写类方法
//: * 重写初始化方法
//: * 重写存储属性

//: _父类_
class Person{
    //存储属性
    var name:String = &quot;person&quot;
    //计算属性
    var rename:String{
        return self.name
    }
    //初始化方法
    init(_ name:String) {
        self.name = name
    }
    //对象方法
    func describe() -&gt; String {
        return self.name
    }
    //类方法
    class func describeClass()-&gt;String{
        return &quot;这是一个描述人的类&quot;
    }
}
//: _子类_
class Man: Person {
    //重写存储属性
    override var name: String{
        didSet{
            print(&quot;man 对象中 name 的原始值：\(self.name)&quot;)
            self.name = &quot;man:&quot;+self.name
        }
    }
    var score : Double
    //重写setter getter
    override var rename: String{
        set{
            self.name = &quot;man:&quot;+newValue
        }
        get{
            return &quot;_&quot;+self.name
        }
    }
    //重写初始化方法
    override init(_ name: String) {
        self.score = 0.0
        super.init(name)
    }
    //重写对象方法
    override func describe() -&gt; String {
        return self.name + &quot;_score:\(self.score)&quot;
    }
    // 重写类方法
    override class func describeClass() -&gt; String {
        return &quot;我是描述男人的类&quot;
    }
}
var man00 = Man(&quot;kael&quot;)
print(man00.name)
</code></pre>
<h3><a id="class%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>class 的类型检测</h3>
<ol>
<li>首先在自己的初始化方法中先给自己的属性初始化</li>
<li>然后调用父类的初始化</li>
<li>最后修改父类的属性</li>
</ol>
<pre><code class="language-plain_text">//: ### 类型检测  is  as?
var person01 = Person(&quot;person01&quot;)
var man01 = Man(&quot;man01&quot;)

if person01 is Person {
    print(&quot;person01：我是Person&quot;)
}else{
    print(&quot;person01：我不是Person&quot;)
}
if person01 is Man {
    print(&quot;person01：我是Man&quot;)
}else{
    print(&quot;person01：我不是Man&quot;)
}
if man01 is Person {
    print(&quot;man01：我是Person&quot;)
}else{
    print(&quot;man01：我不是Person&quot;)
}
if man01 is Man {
    print(&quot;man01：我是Man&quot;)
}else{
    print(&quot;man01：我不是Man&quot;)
}

if let p = person01 as? Person {
    print(&quot;person01 是 Person&quot;)
}
if let p = person01 as? Man{
    print(&quot;person01 是Man&quot;)
}else{
    print(&quot;person01 不是Man&quot;)
}
if let p = man01 as? Person {
    print(&quot;man01 是 Person&quot;)
}
if let p = man01 as? Man{
    print(&quot;man01 是Man&quot;)
}else{
    print(&quot;man01 不是Man&quot;)
}


</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络是怎样连接的]]></title>
    <link href="http://kaelinda.top/15341646765442.html"/>
    
    <updated>2018-08-13T20:51:16+08:00</updated>
    <id>http://kaelinda.top/15341646765442.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E7%94%9F%E6%88%90http%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成HTTP请求信息</h2>
<p>URL种类：<code>http:</code> <code>ftp:</code> <code>file:</code> <code>mailto:</code> <code>news:</code></p>
<p>URL组成：协议 + 用户名(可省略) + 密码(省略) + 服务器域名 + 端口号(可省略) + 文件路径名</p>
<p><figure><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fu8d5d2w7jj313e19atf8.jpg" alt="" /></figure></p>
<h3><a id="%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络请求</h3>
<p><figure><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fu8fexsc00j313a10ewp6.jpg" alt="" /></figure></p>
<h3><a id="http" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP</h3>
<ul>
<li><code>URI</code>：Uniform Resource Identifier，统一资源标识符</li>
<li><code>CGI</code>：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI</li>
</ul>
<h3><a id="dns%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS服务器</h3>
<p>DNS查询服务包含下面三部分：</p>
<ul>
<li><code>域名</code>：服务器、邮件服务器(邮件地址中 @ 后面的部分)的名称</li>
<li><code>Class</code>：在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而 Class 就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN</li>
<li><code>记录类型</code>:表示域名对应何种类型的记录。例如，当类型为 A 时，表示域名 对应的是 IP 地址;当类型为 MX 时，表示域名对应的是邮件服务 器。对于不同的记录类型，服务器向客户端返回的信息也会不同</li>
</ul>
<p><figure><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fubcsxb3lzj318812ualm.jpg" alt="DNS服务器的基本工作" /><figcaption>DNS服务器的基本工作<figcaption></figure></p>
<p><strong>敲黑板，划重点！！！</strong></p>
<blockquote>
<p>上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意 一个域的 DNS 服务器；
根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中，任何 DNS 服务器就都可 以找到并访问根域 DNS 服务器了。</p>
</blockquote>
<p>协议栈传输数据：</p>
<ol>
<li>服务器一方创建套接字，等待客户端向该套接字连接管道 (创建套接字阶段)</li>
<li>客户端创建一个套接字，然后从该套接字伸出管道去连接服务端的套接字 (创建套接字阶段 、连接套接字阶段)</li>
<li>客户端套接字 和 服务端套接字建立连接以后就可以传输网络数据了（数字信息 digital data）(通信阶段)</li>
<li>断开通道、删除套接字 (断开阶段)</li>
</ol>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fup9h6snmhj316s0zg7ah.jpg" alt="" /></figure></p>
<ul>
<li>描述符:应用程序用来识别套接字的机制</li>
<li>IP 地址和端口号:客户端和服务器之间用来识别对方套接字的机制
<figure><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fupfvmg5jwj31j40x60xr.jpg" alt="" /></figure></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alfred workflow 教程]]></title>
    <link href="http://kaelinda.top/15282021908171.html"/>
    
    <updated>2018-06-05T20:36:30+08:00</updated>
    <id>http://kaelinda.top/15282021908171.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简介</h2>
<blockquote>
<p>新创建一个空白的workflow
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fs193q68k7j30we0kawh2.jpg" alt="" /></figure>
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fs194xjqm9j30k804g0t0.jpg" alt="" /></figure></p>
</blockquote>
<ul>
<li>1.workflow 名字</li>
<li>2.workflow功能描述</li>
<li>3.Category：workflow的类别 工具  网络 或者别的分类</li>
<li>4.唯一标识</li>
<li>5.作者</li>
<li>6.网站</li>
</ul>
<blockquote>
<p>空白区，点击鼠标右键
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fs0l0zl2crj307e0bydgg.jpg" alt="" /></figure></p>
</blockquote>
<blockquote>
<p>知识点：{query}   可以接收上个模块的输出参数
如果是输出多个参数，那就是{var:var1,var:var2}</p>
</blockquote>
<h2><a id="triggers%E8%A7%A6%E5%8F%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Triggers 触发器</h2>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fs0ljq33rnj30g20c20ua.jpg" alt="" /></figure></p>
<h3><a id="hotkey%E7%83%AD%E9%94%AE%E8%A7%A6%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hotkey 热键触发</h3>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fs16vk8gidj30to0n4tc1.jpg" alt="" /></figure>
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fs16yvki0ej30jy04qdgs.jpg" alt="" /></figure>
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fs16zp561fj30my05yt9m.jpg" alt="" /></figure></p>
<ul>
<li>
<p>Hotkey: 热键设置触发   选中后可以设置激活热键组合</p>
</li>
<li>
<p>Action: 行为</p>
<ul>
<li>Pass through to workflow</li>
<li>Show Alfred</li>
</ul>
<blockquote>
<p>当热键被按下时该怎么做。注意，如果你选择“show alfred”。即使连接成功，则不会从该处理器的输出中输出任何内容。</p>
</blockquote>
</li>
<li>
<p>Argument：</p>
<ul>
<li>none：什么都没有</li>
<li>selection in macOS: 电脑中选中的内容</li>
<li>MacOS Clipboard Content：电脑粘贴板内容</li>
<li>Text： 输入文本</li>
</ul>
</li>
<li>
<p>prefix	：前缀</p>
<blockquote>
<p>Argument是一个可选参数，如果输入的是文本那么会动态的添加prefix配置的前缀。</p>
</blockquote>
</li>
</ul>
<h3><a id="remote%E8%BF%9C%E7%A8%8B%E8%A7%A6%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Remote 远程触发</h3>
<blockquote>
<p>注意，这个触发器对象与远程对象是分离的。这里提供的图像和名称是建议默认的，并在使用中复制到Remote中。只要保持标识符的一致性，就可以删除和替换对象。</p>
</blockquote>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fs17yod1hlj30vq0k20wk.jpg" alt="" /></figure></p>
<ul>
<li>1.这是自定制的要触发的workflow 的 icon</li>
<li>2.这是按钮上的button上的文字</li>
<li>3.这个触发器内部使用的唯一标识符，通过远程标识要运行哪个触发器。</li>
<li>4.触发器携带参数</li>
<li>5.触发器携带参数前缀</li>
<li>6.此触发器仅可用于添加到此工作流中的远程页面，而不能用于一般的远程页面。</li>
</ul>
<h3><a id="snippet%E7%89%87%E6%AE%B5%E8%A7%A6%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Snippet  片段触发</h3>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fs3mx57k39j30qa0j4wh3.jpg" alt="" /></figure></p>
<ul>
<li>1.关键字：</li>
<li>关注APP的变量</li>
<li></li>
</ul>
<h3><a id="external%E6%89%A9%E5%B1%95%E8%A7%A6%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>External  扩展触发</h3>
<p>触发该触发器后会执行一段Applescript 脚本</p>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fs3pxvlwyvj30ui0futb2.jpg" alt="" /></figure></p>
<ul>
<li>1.identifier : 触发ID</li>
<li>2.简单脚本</li>
</ul>
<h3><a id="connect-action" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Connect Action</h3>
<p>联系人Action，这个具体干什么笔者也没搞清楚。</p>
<h3><a id="fallback-search" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fallback search</h3>
<blockquote>
<p>select the title and subtext you would like to use for this keyword based input.
these represent the text you see in Alfred’s results when using the keyword.</p>
</blockquote>
<p>选择您希望用于这个基于关键字的输入的标题和字幕。这些代表在使用关键字时在Alfred的结果中看到的文本。</p>
<h2><a id="inputs%E8%BE%93%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inputs 输入</h2>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fs0ll364vbj30f80bymye.jpg" alt="" /></figure></p>
<h3><a id="%E5%85%B3%E9%94%AE%E5%AD%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关键字</h3>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fs3qapb1rnj30qw0f277f.jpg" alt="" /></figure></p>
<ul>
<li>1.keyword：激活改Action的关键字</li>
<li>2.是否需要参数：require-必须传入参数  optional-可选  NO argument-不需要参数</li>
<li>3.action 标题</li>
<li>4.action的副标题</li>
<li>5.可以自定制的icon</li>
</ul>
<h3><a id="%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件过滤器</h3>
<p><figure><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fs3qecoaf0j31060ogtc1.jpg" alt="" /></figure></p>
<ul>
<li>1.keyword：激活改Action的关键字</li>
<li>2.默认提示字符标题</li>
<li>3.默认提示字符副标题</li>
<li>4.文件类型 右下角+号可以添加文件类型</li>
</ul>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fs3qykwxjqj31060ogdis.jpg" alt="" /></figure></p>
<p>Search Scope 设置的是可搜索范围。需要手动将文件夹拖入条目范围中，即可。</p>
<p><figure><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fs3qzl6u7nj31060o6te8.jpg" alt="" /></figure></p>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fs3wm2d3mfj316u0ocjzc.jpg" alt="" /></figure></p>
<ul>
<li>1.日期搜索范围设置  任意日期，今天，三天内，七天内，30天内，超过30天</li>
<li>2.文件排序方式设置 名字</li>
</ul>
<h3><a id="%E8%AF%AD%E8%A8%80%E8%BF%87%E6%BB%A4%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语言过滤器</h3>
<p>预言过滤  具体也不知道能干啥。</p>
<p><figure><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fs3r25at3ij30v00h8tbm.jpg" alt="" /></figure></p>
<h3><a id="list%E8%BF%87%E6%BB%A4%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>List过滤器</h3>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fs3r5fichuj31bs0u6gsx.jpg" alt="" /></figure></p>
<p>这就相当于 编程预言里面的 <code>switch case</code></p>
<ul>
<li>1.关键字</li>
<li>2.模块标题</li>
<li>3.模块的subtitle</li>
<li>4.参数配置：require-必须传参 optional-可选   No argument-不需要参数</li>
<li>5.该模块的icon设置</li>
<li>6.list：输入关键字后会出现这个list</li>
<li>7.list子模块title</li>
<li>8.子模块的subtitle</li>
<li>9.选中子模块后输出的参数</li>
<li>10.list中的子模块排序方式   一种是一直保持固定排序；另一种是Alfred自己学习根据使用频率 进行排序</li>
</ul>
<h3><a id="script-filter%E8%84%9A%E6%9C%AC%E8%BF%87%E6%BB%A4%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Script filter 脚本过滤器</h3>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fs3zcesy1gj317e0zmjwi.jpg" alt="" /></figure></p>
<h2><a id="action%E8%A1%8C%E4%B8%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Action 行为</h2>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fs0llhujngj30go0g840r.jpg" alt="" /></figure></p>
<h3><a id="%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打开文件</h3>
<p>用某个APP打开指定文件。</p>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fs3zldzgjzj30yw0rw778.jpg" alt="" /></figure></p>
<h3><a id="reveal-file-in-the-finder%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reveal file in the finder 打开文件所在位置</h3>
<h3><a id="browse-in-alfred" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>browse in Alfred</h3>
<h3><a id="launch-apps" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Launch APPs</h3>
<h3><a id="default-web-search" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default web search</h3>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fs3zrfdl12j30ma0aidha.jpg" alt="" /></figure></p>
<h3><a id="open-url" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>open URL</h3>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fs3zvl5nuwj30zk0didj1.jpg" alt="" /></figure></p>
<h3><a id="system-command" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>System Command</h3>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fs3zz6vwjxj30q00judkl.jpg" alt="" /></figure></p>
<h3><a id="itunes-command" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iTunes Command</h3>
<p><figure><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fs3zzs0mrnj30no0ig42v.jpg" alt="" /></figure></p>
<h3><a id="terminal-command" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Terminal Command</h3>
<p>通过终端APP 运行终端命令组件</p>
<h3><a id="run-script" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run Script</h3>
<p>运行脚本</p>
<h3><a id="run-nsapplescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run NSAppleScript</h3>
<p>运行apple 脚本</p>
<h2><a id="utilities%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilities 实用工具</h2>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fs16kjx74kj30e60fojsx.jpg" alt="" /></figure></p>
<h3><a id="arg-and-vars" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arg and Vars</h3>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fs403j1t5aj30ws0nqmzg.jpg" alt="" /></figure></p>
<h3><a id="json-config" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JSON Config</h3>
<p>通过输入的参数 自行组合成自己想要的json文本</p>
<h3><a id="junction%E7%BB%93%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Junction  结点</h3>
<p>这个只是处理复杂逻辑的节点。如果线条逻辑过多 错综复杂的时候 可以通过节点来处理。</p>
<h3><a id="filter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter</h3>
<h3><a id="delay" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delay</h3>
<h3><a id="transform" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transform</h3>
<h3><a id="replace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Replace</h3>
<h3><a id="hide-alfred" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hide Alfred</h3>
<h3><a id="debug" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debug</h3>
<h2><a id="outputs%E8%BE%93%E5%87%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Outputs 输出</h2>
<p><figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fs16lacns8j30h60eqtai.jpg" alt="" /></figure></p>
<h3><a id="post-notification%E5%8F%91%E9%80%81%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Post Notification 发送本地通知</h3>
<p>发送本地通知。Alfred 3 的本地推送不好用，一直没成功。</p>
<h3><a id="large-type%E5%A4%A7%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Large Type 大文字显示</h3>
<p>大文字显示 一些文本。</p>
<h3><a id="copy-to-clipboard-copy%E6%96%87%E6%9C%AC%E5%88%B0%E7%B2%98%E8%B4%B4%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Copy to Clipboard  copy文本到粘贴板</h3>
<p>复制结果到粘贴板</p>
<h3><a id="write-text-file%E6%8A%8A-text%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Write Text File 把text写入文件</h3>
<p>将text文本写入文件</p>
<h3><a id="play-sound%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Play Sound 播放声音</h3>
<p>播放声音</p>
<h3><a id="dispath-key-combo%E6%8C%89%E9%94%AE%E8%BF%9E%E5%87%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dispath Key Combo 按键连击</h3>
<h3><a id="call-external-trigger%E8%A7%A6%E5%8F%91%E5%88%AB%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Call External trigger 触发别的触发器</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能（8）]]></title>
    <link href="http://kaelinda.top/15232599795686.html"/>
    
    <updated>2018-04-09T15:46:19+08:00</updated>
    <id>http://kaelinda.top/15232599795686.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="shell%E7%BB%88%E7%AB%AF%E6%89%93%E5%8D%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell 终端打印</h2>
<pre><code class="language-plain_text">```
printf &quot;%-5s %-10s %-4s \n&quot; NO Name Mark
printf &quot;%-5s %-10s %-4s \n&quot; 1 kael 100
printf &quot;%-5s %-10s %-4s \n&quot; 2 linda 99
printf &quot;%-5s %-10s %-4s \n&quot; 3 rouse 98

// 打印结果
NO    Name       Mark 
1     kael       100  
2     linda      99   
3     rouse      98  
```
</code></pre>
<blockquote>
<p>printf 行尾 默认自带换行 \n</p>
</blockquote>
<ul>
<li>%-5s : 左对齐，宽度为5的字符串替换；默认右对齐</li>
<li>%-4.2f:指定保留2位小数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能（7）]]></title>
    <link href="http://kaelinda.top/15226648731246.html"/>
    
    <updated>2018-04-02T18:27:53+08:00</updated>
    <id>http://kaelinda.top/15226648731246.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件包含 导入文件</h2>
<p>测试文件  test1.sh</p>
<pre><code class="language-plain_text">#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

url=&quot;http://www.runoob.com&quot;
</code></pre>
<p>测试文件 test2.sh</p>
<pre><code class="language-plain_text">#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

#使用 . 号来引用test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh

echo &quot;菜鸟教程官网地址：$url&quot;
</code></pre>
<span id="more"></span><!-- more -->
<pre><code class="language-plain_text">$ chmod +x test2.sh 
$ ./test2.sh 
菜鸟教程官网地址：http://www.runoob.com
</code></pre>
<h2><a id="%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>输入/输出  重定向</h2>
<table>
<thead>
<tr>
<th style="text-align: center">命令</th>
<th style="text-align: center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">command &gt; file</td>
<td style="text-align: center">先清空文件中内容，将输出重定向到文件</td>
</tr>
<tr>
<td style="text-align: center">command &lt; file</td>
<td style="text-align: center">将输入重定向到文件</td>
</tr>
<tr>
<td style="text-align: center">command &gt;&gt; file</td>
<td style="text-align: center">将输出以追加的形式重定向到file</td>
</tr>
<tr>
<td style="text-align: center">N &gt; file</td>
<td style="text-align: center">将描述符为N的文件，重定向到文件file</td>
</tr>
<tr>
<td style="text-align: center">N &gt;&gt; file</td>
<td style="text-align: center">将描述符为N的文件，追加到file</td>
</tr>
<tr>
<td style="text-align: center">n&gt;&amp;m</td>
<td style="text-align: center">将输出文件m 和  n合并</td>
</tr>
<tr>
<td style="text-align: center">n&lt;&amp;m</td>
<td style="text-align: center">将输入文件m 和 n合并</td>
</tr>
<tr>
<td style="text-align: center">&lt;&lt;tag</td>
<td style="text-align: center">将开始标记为tag何结尾标记为tag 之间的内容作为输入</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能（6）]]></title>
    <link href="http://kaelinda.top/15226603064743.html"/>
    
    <updated>2018-04-02T17:11:46+08:00</updated>
    <id>http://kaelinda.top/15226603064743.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="test" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>test</h2>
<h3><a id="test%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>test文件</h3>
<pre><code class="language-plain_text">if test -e ./test.sh
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi
</code></pre>
<ul>
<li>-e fileName ： 如果文件存在则为真</li>
<li>-r  fileName : 如果文件存在且可读则为真</li>
<li>-w fileName : 如果文件存在且可写则为真</li>
<li>-x fileName : 如果文件存在且可执行则为真</li>
<li>-s fileName: 文件存在且至少有一个字符</li>
<li>-d fileName : 文件存在且为目录</li>
<li>-f fileName: 文件存在且为文件</li>
<li>-c fileName:文件存在，且为字符型特殊文件</li>
<li>-b fileName: 如果文件存在且为块特殊文件则为真</li>
</ul>
<span id="more"></span><!-- more -->
<h3><a id="test%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>test字符串</h3>
<ul>
<li>= ：等于则为真</li>
<li>!= :不等于则为真</li>
<li>-z : 字符串长度为零则为真</li>
<li>-n : 字符串长度不为零则为真</li>
</ul>
<h3><a id="%E6%95%B0%E5%80%BC%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数值测试</h3>
<ul>
<li>-eq :等于</li>
<li>-ne : 不等于</li>
<li>-gt:大于</li>
<li>-lt:小于</li>
<li>-ge:大于等于</li>
<li>-le: 小于等于</li>
</ul>
<h2><a id="%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流程控制(条件)</h2>
<h3><a id="if" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>if</h3>
<pre><code class="language-plain_text">if condition
then
    command1 
    command2
    ...
    commandN 
fi
</code></pre>
<h3><a id="if-else" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>if else</h3>
<pre><code class="language-plain_text">if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
</code></pre>
<h3><a id="if-else-if-else" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>if else-if else</h3>
<pre><code class="language-plain_text">if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
</code></pre>
<p>实例 用法：</p>
<pre><code class="language-plain_text">a=10
b=20
if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
elif [ $a -gt $b ]
then
   echo &quot;a 大于 b&quot;
elif [ $a -lt $b ]
then
   echo &quot;a 小于 b&quot;
else
   echo &quot;没有符合的条件&quot;
fi
</code></pre>
<h2><a id="%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88for%E5%BE%AA%E7%8E%AF%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>控制流（for 循环）</h2>
<pre><code class="language-plain_text">for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
</code></pre>
<p>改成一行：</p>
<pre><code class="language-plain_text">for var in item1 item2 ... itemN; do command1; command2… done;
</code></pre>
<h2><a id="while" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>while</h2>
<pre><code class="language-plain_text">while condition
do
    command
done
</code></pre>
<pre><code class="language-plain_text">int=1
while(( $int&lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done
</code></pre>
<p>无限循环：</p>
<pre><code class="language-plain_text">while :
do
    command
done

// 或者
while true
do
    command
done

// 或者
for (( ; ; ))

</code></pre>
<h2><a id="until%E5%BE%AA%E7%8E%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>until 循环</h2>
<pre><code class="language-plain_text">until condition
do
    command
done
</code></pre>
<h2><a id="case-in" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>case in</h2>
<pre><code class="language-plain_text">case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
</code></pre>
<h2><a id="%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>跳出循环</h2>
<h3><a id="break" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>break</h3>
<blockquote>
<p>break命令允许跳出所有循环（终止执行后面的所有循环）</p>
</blockquote>
<h3><a id="continue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>continue</h3>
<blockquote>
<p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环</p>
</blockquote>
<pre><code class="language-plain_text">while :
do
    echo -n &quot;输入 1 到 5 之间的数字: &quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;
            continue
            echo &quot;游戏结束&quot;
        ;;
    esac
done
</code></pre>
<h3><a id="esac" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>esac</h3>
<blockquote>
<p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能（5）]]></title>
    <link href="http://kaelinda.top/15224936933861.html"/>
    
    <updated>2018-03-31T18:54:53+08:00</updated>
    <id>http://kaelinda.top/15224936933861.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="shell-echo%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shell echo命令</h2>
<h3><a id="%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打印字符</h3>
<pre><code class="language-plain_text">// 下面两行代码效果一致
echo &quot;It is a test&quot;
echo It is a test
</code></pre>
<h3><a id="%E6%89%93%E5%8D%B0%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打印转义字符</h3>
<pre><code class="language-plain_text">echo &quot;\&quot;It is a test\&quot;&quot;
// 引号也可以省略
echo \&quot;It is a test\&quot;
</code></pre>
<p>打印结果：</p>
<pre><code class="language-plain_text">&quot;It is a test&quot;

&quot;It is a test&quot;
</code></pre>
<span id="more"></span><!-- more -->
<h3><a id="%E6%89%93%E5%8D%B0%E9%9A%90%E8%97%8F%E6%8D%A2%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打印 隐藏 换行</h3>
<pre><code class="language-plain_text">// 显示换行
echo -e &quot;OK! \n&quot; # -e 开启转义
echo &quot;It it a test&quot;
// 不显示换行
echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行
echo &quot;It is a test&quot;

</code></pre>
<h3><a id="%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C%E5%AE%9A%E5%90%91%E8%87%B3%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示结果定向至文件</h3>
<pre><code class="language-plain_text">echo &quot;It is a test&quot; &gt; myfile
</code></pre>
<h3><a id="%E5%8E%9F%E6%A0%B7%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%8D%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原样显示字符 不进行转义</h3>
<pre><code class="language-plain_text">echo '$name\&quot;'

// 输出结果：  $name\&quot;
</code></pre>
<h2><a id="%E5%BD%95%E5%85%A5%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>录入参数</h2>
<pre><code class="language-plain_text">read -p &quot;请输入一段文字:&quot; -n 6 -t 5 -s password
echo &quot;\npassword is $password&quot;
</code></pre>
<ul>
<li>-p 输入提示文字</li>
<li>-n 输入字符长度限制(达到6位，自动结束)</li>
<li>-t 输入限时</li>
<li>-s 隐藏输入内容</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能（4）]]></title>
    <link href="http://kaelinda.top/15224613481161.html"/>
    
    <updated>2018-03-31T09:55:48+08:00</updated>
    <id>http://kaelinda.top/15224613481161.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="shell%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell基本运算符</h2>
<p>基本使用：</p>
<pre><code class="language-plain_text">#!/bin/bash

val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;
</code></pre>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样</li>
<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边</li>
</ul>
<span id="more"></span><!-- more -->
<h3><a id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算术运算符</h3>
<table>
<thead>
<tr>
<th style="text-align: center">运算符</th>
<th style="text-align: center">说明</th>
<th style="text-align: center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">+</td>
<td style="text-align: center">加法</td>
<td style="text-align: center">`expr $a + $b` 结果为 30。</td>
</tr>
<tr>
<td style="text-align: center">-</td>
<td style="text-align: center">减法</td>
<td style="text-align: center">`expr $a - $b` 结果为 -10。</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td style="text-align: center">乘法</td>
<td style="text-align: center">`expr $a * $b` 结果为  200。</td>
</tr>
<tr>
<td style="text-align: center">/</td>
<td style="text-align: center">除法</td>
<td style="text-align: center">`expr $b / $a` 结果为 2。</td>
</tr>
<tr>
<td style="text-align: center">%</td>
<td style="text-align: center">取余</td>
<td style="text-align: center">`expr $b % $a` 结果为 0。</td>
</tr>
<tr>
<td style="text-align: center">=</td>
<td style="text-align: center">赋值</td>
<td style="text-align: center">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td style="text-align: center">==</td>
<td style="text-align: center">相等</td>
<td style="text-align: center">[ \(a == \)b ] 返回 false。</td>
</tr>
<tr>
<td style="text-align: center">!=</td>
<td style="text-align: center">不相等</td>
<td style="text-align: center">[ \(a != \)b ] 返回 true。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>条件表达式要放在方括号之间，并且要有空格，例如: [\(a==\)b] 是错误的，必须写成 [ \(a == \)b ]</p>
</blockquote>
<pre><code class="language-plain_text">a=10
b=20

val=`expr ``a + ``b`
echo &quot;a + b : $val&quot;

val=`expr ``a - ``b`
echo &quot;a - b : $val&quot;

val=`expr ``a \* ``b`
echo &quot;a * b : $val&quot;

val=`expr ``b / ``a`
echo &quot;b / a : $val&quot;

val=`expr ``b % ``a`
echo &quot;b % a : $val&quot;

if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;a 不等于 b&quot;
fi
</code></pre>
<h3><a id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关系运算符</h3>
<ul>
<li>-eq: 是否等于</li>
<li>-ne: 是否不等于</li>
<li>-gt: 是否大于</li>
<li>-lt: 是否小于</li>
<li>-ge: 是否大于等于</li>
<li>-le: 是否小于等于</li>
</ul>
<hr />
<blockquote>
<p>EQ 就是 EQUAL等于
NE 就是 NOT EQUAL不等于
GT 就是 GREATER THAN大于　
LT 就是 LESS THAN小于
GE 就是 GREATER THAN OR EQUAL 大于等于
LE 就是 LESS THAN OR EQUAL 小于等于</p>
</blockquote>
<hr />
<pre><code class="language-plain_text">a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h3><a id="%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布尔运算符</h3>
<ul>
<li>!: 非运算</li>
<li>-o: 或运算</li>
<li>-a: 与运算</li>
</ul>
<h3><a id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑运算符</h3>
<ul>
<li>&amp;&amp;：与</li>
<li>||：或</li>
</ul>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串运算</h3>
<pre><code class="language-plain_text">a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a = $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n $a ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能  (3)]]></title>
    <link href="http://kaelinda.top/15223750607281.html"/>
    
    <updated>2018-03-30T09:57:40+08:00</updated>
    <id>http://kaelinda.top/15223750607281.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="shell%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell参数传递</h2>
<p>我们可以在脚本执行时，向脚本传递参数</p>
<pre><code class="language-plain_text">// 终端运行 脚本，并传入参数
sh testBash.sh 0 1 2

echo &quot;Shell 传递参数实例！&quot;

echo &quot;\$0 =&gt; $0&quot;

echo &quot;\$1 =&gt; $1&quot;
</code></pre>
<p>打印结果：</p>
<pre><code class="language-plain_text">Shell 传递参数实例！
$0 =&gt; testBash.sh
$1 =&gt; 0
</code></pre>
<span id="more"></span><!-- more -->
<table>
<thead>
<tr>
<th style="text-align: center">参数处理</th>
<th style="text-align: center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">$#</td>
<td style="text-align: center">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align: center">$*</td>
<td style="text-align: center">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td style="text-align: center">$$</td>
<td style="text-align: center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align: center">$!</td>
<td style="text-align: center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td style="text-align: center">$@</td>
<td style="text-align: center">与$*相同，但是使用时加引号，并在引号中返回每个参数</td>
</tr>
<tr>
<td style="text-align: center">$-</td>
<td style="text-align: center">显示Shell使用的当前选项</td>
</tr>
<tr>
<td style="text-align: center">$?</td>
<td style="text-align: center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误</td>
</tr>
</tbody>
</table>
<pre><code class="language-plain_text">// 运行脚本
sh testBash.sh 0 1 2
</code></pre>
<pre><code class="language-plain_text">echo &quot;\$0 =&gt; $0&quot;

echo &quot;\$1 =&gt; $1&quot;

echo &quot;\$@ =&gt; $@&quot;

echo &quot;\$* =&gt; $*&quot;

echo &quot;\$\$ =&gt; $$&quot;

echo &quot;\$! =&gt; $!&quot;

echo &quot;\$- =&gt; $-&quot;

echo &quot;\$? =&gt; $?&quot;

echo &quot;\$*传递的参数作为一个字符串显示：$*&quot;

echo &quot;\$@是作为一个数组返回 =&gt; $@&quot;
</code></pre>
<p>打印结果：</p>
<pre><code class="language-plain_text">$0 =&gt; testBash.sh
$1 =&gt; 0
$@ =&gt; 0 1 2
$* =&gt; 0 1 2
$$ =&gt; 18859
$! =&gt; 
$- =&gt; hB
$? =&gt; 0
$*传递的参数作为一个字符串显示：0 1 2
$@是作为一个数组返回 =&gt; 0 1 2
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell技能 （1）]]></title>
    <link href="http://kaelinda.top/15223028228569.html"/>
    
    <updated>2018-03-29T13:53:42+08:00</updated>
    <id>http://kaelinda.top/15223028228569.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%87%86%E5%A4%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>准备</h2>
<p>bash 环境位置</p>
<pre><code class="language-plain_text">#!/bin/bash
</code></pre>
<p><code>#!</code> 一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p>
<span id="more"></span><!-- more -->
<h2><a id="%E8%BF%90%E8%A1%8Cshell" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行shell</h2>
<ol>
<li>
<p>作为可执行程序</p>
<pre><code class="language-shell">chmod +x ./mybash.sh
./mybash.sh
</code></pre>
</li>
<li>
<p>作为解释器参数</p>
</li>
</ol>
<pre><code class="language-plain_text">/bin/bash test.sh
/bin/php test.php
// 如果这样运行，文件内的第一行就可以不需要指定 解释器信息了
</code></pre>
<h2><a id="pwd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>pwd</h2>
<ol>
<li>
<p>命令简介</p>
<p><code>pwd</code> ：打印当前目录 ，命令以 <code>绝对路径</code> 的形式显示用户的  当前工作目录</p>
</li>
<li>
<p>用法</p>
<p><code>pwd    [-LP]</code></p>
</li>
</ol>
<h2><a id="%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量</h2>
<h3><a id="%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义变量</h3>
<ul>
<li>定义变量时 不需要制定 <code>$ </code>符号</li>
<li>变量名和值、等号之间不能有空格</li>
</ul>
<p><strong>命名规范:</strong></p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li>
<li>中间不能有空格，可以使用下划线（_）</li>
<li>不能使用标点符号</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）</li>
</ul>
<pre><code class="language-shell">user_name='kael linda'
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用变量</h3>
<p>使用时，变量名前面加上<code>$</code>符号即可</p>
<pre><code class="language-plain_text">your_name=&quot;qinjx&quot;
echo $your_name
echo ${your_name}
</code></pre>
<p>花体括号 加不加都行，视情况而定。
加是为了区分变量边界</p>
<pre><code class="language-plain_text">user_name=&quot;kaelinda&quot;
echo  &quot;I'm ${user_name}' brother&quot;
</code></pre>
<h3><a id="%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>只读变量</h3>
<pre><code class="language-plain_text">user_name=&quot;kaelinda&quot;
readonly user_name
user_name=&quot;kael&quot;
</code></pre>
<h3><a id="%E5%88%A0%E9%99%A4%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除变量</h3>
<pre><code class="language-plain_text">unset variable_name
</code></pre>
<ul>
<li>删除变量删除之后的变量不可再使用</li>
<li>unset 命令不能删除只读变量</li>
</ul>
<h3><a id="%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量类型</h3>
<ul>
<li>局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li>环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li>shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h2><a id="shell%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell 字符串</h2>
<h3><a id="%E5%8D%95%E5%BC%95%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单引号</h3>
<pre><code class="language-plain_text">str='this is a string'
</code></pre>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
</ul>
<h3><a id="%E5%8F%8C%E5%BC%95%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双引号</h3>
<pre><code class="language-plain_text">your_name='qinjx'
str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;
</code></pre>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h3><a id="%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拼接字符串</h3>
<pre><code class="language-plain_text">your_name=&quot;qinjx&quot;
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取字符串长度</h3>
<pre><code class="language-plain_text">string=&quot;abcd&quot;
echo ${#string} #输出 4
</code></pre>
<h3><a id="%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提取字符串</h3>
<pre><code class="language-plain_text">string=&quot;runoob is a great site&quot;
echo ${string:1:4} # 输出 unoo
</code></pre>
<h3><a id="%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找字符串位置</h3>
<pre><code class="language-plain_text">string=&quot;runoob is a great company&quot;
echo `expr index &quot;$string&quot; is`  # 输出 8
</code></pre>
<blockquote>
<p>以上脚本中 &quot;`&quot; 是反引号，而不是单引号 &quot;'&quot;，不要看错了.  这是用了正则表达式匹配字符</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[每天学习一个shell 技能 （2）]]></title>
    <link href="http://kaelinda.top/15223210751913.html"/>
    
    <updated>2018-03-29T18:57:55+08:00</updated>
    <id>http://kaelinda.top/15223210751913.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="shell%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shell 数组</h2>
<h3><a id="%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义数组</h3>
<pre><code class="language-bash">array_name=(value1 value2 value3)

array_name2=(
value1
value2
value3
)

// 单独定义某个分量的值
array_name(0)=value0
</code></pre>
<span id="more"></span><!-- more -->
<h3><a id="%E8%AF%BB%E5%8F%96%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读取数组</h3>
<pre><code class="language-plain_text">// 读取单个元素
value0=${array_name[0]}

//使用@符号可以获取数组中的所有元素
echo ${array_name(@)}

</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取数组的长度</h3>
<pre><code class="language-plain_text">// 获取元素个数
length=${#array_name[@]}

//或者
length=${#array_name[*]}

// 获取的单个元素的长度
item_length=${#array_name[n]}
</code></pre>
<h2><a id="shell%E6%B3%A8%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shell 注释</h2>
<blockquote>
<p>以&quot;#&quot;开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。只能像这样</p>
</blockquote>
<pre><code class="language-plain_text">#--------------------------------------------
# 这是一个注释
# author：菜鸟教程
# site：www.runoob.com
# slogan：学的不仅是技术，更是梦想！
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 用户配置区 结束  #####
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从零开始学习使用 vuex]]></title>
    <link href="http://kaelinda.top/15168925544178.html"/>
    
    <updated>2018-01-25T23:02:34+08:00</updated>
    <id>http://kaelinda.top/15168925544178.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<blockquote>
<p>本文是建立在，对vuex理论有一定理解的基础上写的。
因为官方文档的写法是 针对 有一定的vue开发经验 和 JavaScript 有一定理解的开发者看的，对于小白级别的我来说，理解起来有一定困难。所以，唯一想我一向的小白想尽快上手vuex....</p>
</blockquote>
<p><a href="https://vuex.vuejs.org/zh-cn/installation.html">详情请参考vuex官方文档</a></p>
<h2><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h2>
<h3><a id="%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BDcdn%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接下载 CDN 安装</h3>
<p>CDN 链接地址：<code>https://unpkg.com/vuex</code>
指定到固定版本：<code>https://unpkg.com/vuex@2.0.0</code></p>
<pre><code class="language-plain_text">&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3><a id="npm%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%81%E7%AE%80%E5%8D%95%E5%BF%AB%E6%8D%B7%EF%BC%8C%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>npm 方式安装 （推荐！简单快捷，便于管理）</h3>
<p><code>npm install -save vuex</code></p>
<h3><a id="yar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>yar</h3>
<p><code>yarn add vuex</code></p>
<h3><a id="%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自己构建</h3>
<pre><code class="language-bash">git clone https://github.com/vuejs/vuex.git node_modules/vuex
cd node_modules/vuex
npm install
npm run build
</code></pre>
<h2><a id="%E5%AF%BC%E5%85%A5vue%E5%B7%A5%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导入vue工程中使用</h2>
<ul>
<li>main.js 入口文件</li>
</ul>
<blockquote>
<p>按照如下方式导入，工程就可以使用vuex的环境了</p>
</blockquote>
<pre><code class="language-JavaScript">// 导入vuex头文件
import Vuex from 'vuex'
// 这里表示全局导入vuex
Vue.use(Vuex)
// 这里是我自定义的store文件 导出store对象
import store from '@/study/vuexStudy/store/store.js'
</code></pre>
<blockquote>
<p>入口组件<App/>中，绑定store</p>
</blockquote>
<pre><code class="language-plain_text">new Vue({
  el: '#app',
  template: '&lt;App/&gt;',
  components: { App },
  store
})
</code></pre>
<p>到这里 算是万里长征走了第一步。</p>
<h3><a id="%E5%88%9B%E5%BB%BAstore%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Store对象</h3>
<h4><a id="store%E7%9A%84%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>store 的结构:</h4>
<pre><code class="language-JavaScript">export const store = new Vuex.Store({

  // ------state:状态值存储,这里可以存储n个状态的值
  state: {count: '1'},
  
  // ------getter:store中定义的getters可以认为是store的计算属性
  // getters接收state作为其第一个参数
  getters: {
    done (state) {
      return state.count + 5
    }
  },
  
  // ------mutations:状态值的改变，操作状态值
  // $store.commit(mutationsName, params)是更改状态值的唯一方法
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  },

  // ------actions:可以认为是包装了mutations的function 需要用 dispatch(actionName) 的方式去派发
  actions: {
    add (context) {
      context.commit('increment')
    },
    addAsync (context) {
      // 延时1秒
      setTimeout(() =&gt; {
        context.commit('increment')
      }, 1000)
    }
  },
  // store可以合并几个子store，以此来进行项目的模块化
  modules: {
    a: moduleA,
    b: moduleB
  }
})
</code></pre>
<h4><a id="%E7%BC%96%E8%BE%91%E5%AE%9A%E4%B9%89store%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编辑定义store实体对象：</h4>
<ul>
<li>store.js文件中</li>
</ul>
<blockquote>
<p>这里为了便于抽离 我们外部声明城对象实体后嵌入绑定到store</p>
</blockquote>
<ol>
<li>
<p>创建一个store对象</p>
<pre><code class="language-JavaScript">export default const store = new Vuex.Store({
  state,//绑定之前创建的state对象到store中
  mutations,
  getters,
  actions,
  modules
})
</code></pre>
</li>
<li>
<p>定义一个状态对象 <code>state</code>（实体）</p>
<pre><code class="language-JavaScript">const state = {
  count: 0,
  state1: 1,
  state2: 2,
  state3: 3
}
</code></pre>
</li>
<li>
<p>定义getters对象</p>
<pre><code class="language-plain_text">const getters = {
  done (state) {
    return state.count + 5
  },
  getState1: function (state) {
    return state.state3
  },
  // ES6简写
  getState2: state =&gt;  state.state2
}
</code></pre>
</li>
<li>
<p>.vue 文件中直接获取state值</p>
<p>首先导入辅助函数：</p>
<pre><code class="language-plain_text">import { 
    mapState, 
    mapGetters, 
    mapMutations, 
    mapActions 
    } from 'vuex'
</code></pre>
<ul>
<li>第一种方式：绑定到组件属性中，直接获取 （一般不用这个，绑定到computed中是最合适的）<code>$store.state.count</code>并使用</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    }
}
</code></pre>
<ul>
<li>第二种方式： 绑定到计算属性中（适合对store中的原始状态值进行一定处理的情况）</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        }
    }
}
</code></pre>
<ul>
<li>第三种方式：mapState辅助函数绑定状态state值到组件计算属性中</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
    }
}
</code></pre>
<ul>
<li>第四种方式：使用store中绑定的getters进行获取</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
        testComputedGettersCount2: funtion () {
            return this.$store.getters.done
        }
    }
}
</code></pre>
<ul>
<li>第五种方式： 借助mapGetters辅助函数绑定getters到vue的计算属性中</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
        testComputedGettersCount2: funtion () {
            return this.$store.getters.done
        },
        
        //直接绑定方法数组的方式
        ...mapGetters([
            'getState1',
            'getState2',
            'getState3'
        ]),
        
        //重命名对象绑定方式
        ...mapGetters({
          mapGetterState1: 'getState1',
          mapGetterState3: 'getState3'
        }),
    }
}
</code></pre>
</li>
<li>
<p>触发动作行为改变状态值</p>
<blockquote>
<p>方式一：$store.commit('mutationsName')</p>
</blockquote>
<blockquote>
<p>方式二：$store.dispatch('actionsName')</p>
</blockquote>
<p>store.js文件中：</p>
<ul>
<li>初始化 mutations 和 actions (相当于是methods)</li>
</ul>
<pre><code class="language-plain_text">const mutations = {
    increment (state) {
        // 变更状态
        state.count = state.count * 5
    }
}
</code></pre>
<pre><code class="language-plain_text">import {action4} from '@/path/actions.js'
const actions = {
    // 同步方法
    add: function (context) {
        context.commit('increment')
    },
    // 延时操作 用于网络请求啊啥的
    addAsync (context) {
        // 延时1秒
        setTimeout(() =&gt; {
            context.commit('increment')
        }, 1000)
    },
    // 简写方式
    action2 (context) {
        context.commit('increment')
    },
    // 抽离到单独文件中，在导进封装好的变量来直接使用即可（导进来的目的是为了接收第一个参数：state），不绑定到store，需要手动传入store对象
    action4: action4,
}
</code></pre>
</li>
</ol>
<ul>
<li>
<p>绑定action 和 mutations 到 methods，然后 调用就行了</p>
<pre><code class="language-plain_text">export default {
    methods: {
        // 数组形式直接载入
        ...mapActions([
            'add'
        ]),
        // 重命名形式 
        ...mapActions({
            add: 'add',
            addAsync: 'addAsync',
            action4: 'action4'
        }),
        // 同上
        ...mapMutations([
            'increment'
        ]),
        ...mapMutations({
            incrementMutation: 'increment'
        })
    }
}
</code></pre>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给安卓项目添加启动图]]></title>
    <link href="http://kaelinda.top/15151216159291.html"/>
    
    <updated>2018-01-05T11:06:55+08:00</updated>
    <id>http://kaelinda.top/15151216159291.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h1><a id="react-native-splash-screen" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>react-native-splash-screen</h1>
<p>给安卓项目添加启动图</p>
<h2><a id="react-native-splash-screen%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>react-native-splash-screen 基本配置</h2>
<ul>
<li>安装插件：<code>npm install react-native-splash-screen --save</code></li>
<li>关联项目：<code>react-native link react-native-splash-screen</code> or <code>rnpm link react-native-splash-screen</code></li>
</ul>
<blockquote>
<p>link 之后，安卓项目中会自动添加头文件 以及部分代码，为保证项目顺利运行，还请确认下面代码是否已经完善。</p>
</blockquote>
<ul>
<li>
<p>确保 <code>android/settings.gradle</code>文件夹已经有下面代码</p>
<pre><code class="language-JavaScript"></code></pre>
</li>
</ul>
<p>include ':react-native-splash-screen'<br />
project(':react-native-splash-screen').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-splash-screen/android')</p>
<pre><code class="language-plain_text">* android/app/build.gradle 文件中 添加依赖 `react-native-splash-screen`

    ```
...
dependencies {
    ...
    compile project(':react-native-splash-screen')
}
</code></pre>
<span id="more"></span><!-- more -->
<ul>
<li>更新 <code>MainApplication.java</code> 文件</li>
</ul>
<pre><code class="language-plain_text">// react-native-splash-screen &gt;= 0.3.1
import org.devio.rn.splashscreen.SplashScreenReactPackage;
// react-native-splash-screen &lt; 0.3.1
import com.cboy.rn.splashscreen.SplashScreenReactPackage;

public class MainApplication extends Application implements ReactApplication {

    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
        protected boolean getUseDeveloperSupport() {
            return BuildConfig.DEBUG;
        }

        @Override
        protected List&lt;ReactPackage&gt; getPackages() {
            return Arrays.&lt;ReactPackage&gt;asList(
                    new MainReactPackage(),
            new SplashScreenReactPackage()  //here
            );
        }
    };

    @Override
    public ReactNativeHost getReactNativeHost() {
        return mReactNativeHost;
    }
}
</code></pre>
<h2><a id="%E5%87%86%E5%A4%87%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%92%8C%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>准备添加代码和文件配置</h2>
<ul>
<li><code>app/src/main/res/layout</code> 文件夹下 添加 <code>launch_screen.xml</code> 并copy如下代码：</li>
</ul>
<pre><code class="language-plain_text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@drawable/launch_screen&quot;&gt;
&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li>
<p>创建文件夹 <code>drawable-xhdpi</code>、 <code>drawable-xxhdpi</code>（暂时先创建这两个就够了），将准备好的启动图 命名为 <code>launch_screen.png</code> 分别放入创建好的文件夹</p>
</li>
<li>
<p>白屏问题，设置透明背景：<code>android/app/src/main/res/values/styles.xml</code> 文件夹下 添加 <code>&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</code></p>
<pre><code class="language-plain_text"></code></pre>
</li>
</ul>
<resources>
    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <!-- Customize your theme here. -->
        <!--设置透明背景-->
        <item name="android:windowIsTranslucent">true</item>
    </style>
</resources>
```
<ul>
<li>
<p><code>android/app/src/main/res/values/colors.xml</code> 文件夹下，添加如下：</p>
<pre><code class="language-plain_text"></code></pre>
</li>
</ul>
<?xml version="1.0" encoding="utf-8"?> <resources> <color name="primary_dark">#660B0B0B</color> </resources>
<pre><code class="language-plain_text">
* 适当的时刻 隐藏启动图  可以是在视图挂载完毕，可以是网络请求结束之后


</code></pre>
<p>import SplashScreen from 'react-native-splash-screen'
componentDidMount() {
SplashScreen.hide();
}</p>
<pre><code class="language-plain_text">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rect-Native 之 Promise 深入浅出从入门到精通]]></title>
    <link href="http://kaelinda.top/15139057022845.html"/>
    
    <updated>2017-12-22T09:21:42+08:00</updated>
    <id>http://kaelinda.top/15139057022845.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念理解</h2>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fhp9dw6vxpj307406ewek.jpg" alt="icon" title="React icon" /><figcaption>icon<figcaption></figure></p>
<blockquote>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
</blockquote>
<span id="more"></span><!-- more -->
<h3><a id="promise%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 状态</h3>
<ul>
<li>Pending 进行中</li>
<li>Resolved 已完成 又称Fulfilled</li>
<li>Rejected 已失败</li>
</ul>
<h3><a id="promise%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 特点</h3>
<ul>
<li>对象的状态不受外部因素影响。Promise对象代表的是一个异步操作，只有异步操作的结果能决定Promise的状态，任何其他操作都不能决定其状态。</li>
<li>一旦Promise有了结果状态就不会再变。<code>Pending==&gt;Resolved</code>,或者<code>Pending==&gt;Rejected</code></li>
</ul>
<h3><a id="promise%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 缺点</h3>
<p>Promise的缺点是：一旦建立就会立即执行，无法中途取消。</p>
<h2><a id="promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 基本用法</h2>
<pre><code class="language-JavaScript">var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
</code></pre>
<p>Promise对象接受一个参数，这个参数是一个函数体。
这个函数有两个参数：一个是resolve，一个是reject。这两个参数是Promise自动提供，不需要使用者传值。</p>
<ul>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
Promise实例生成后，可以用then分别指定Resolved和Rejected的回调函数。</li>
</ul>
<pre><code class="language-JavaScript">promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre>
<p>then方法会接受两个参数：</p>
<ul>
<li>第一个函数，Promise状态变更为Resolved时调用。</li>
<li>第二个函数，Promise状态变为Rejected时调用。可选的，可以不提供。</li>
</ul>
<p>下面是异步加载图片的例子：</p>
<pre><code class="language-JavaScript">function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    var image = new Image();

    image.onload = function() {
      resolve(image);
    };

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };

    image.src = url;
  });
}
</code></pre>
<p>下面是Promise实现的Ajax操作的例子：</p>
<pre><code class="language-JavaScript">var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });

  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
</code></pre>
<p><strong>注意：在getJSON内部，resolve函数和reject函数调用时，都带有参数！！</strong><br />
如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。</p>
<ul>
<li>reject函数的参数通常是Error对象的实例，表示抛出的错误</li>
<li>resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作</li>
</ul>
<pre><code class="language-JavaScript">var p1 = new Promise(function (resolve, reject) {
  // ...
});

var p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>
<p>上面👆，<code>p1</code>、<code>p2</code> 都是Promise，但是<code>p2</code>的resolve把<code>p1</code>作为返回值参数传出去了，即一个异步操作的返回结果是另一个异步操作。（类似于iOS开发中的自动布局库 <code>Masonry</code>,可以无限点语法取到对象）。<br />
<strong>注意：此时，p1的状态会传递p2.如果p1是Pending状态,那么p2会等待p1的结果。如果p1是Reject或者Resolve状态，那么p2的回调函数将会立即执行。</strong></p>
<p><strong>再看:</strong></p>
<pre><code class="language-JavaScript">var p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000)
})

var p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 1000)
})

p2.then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre>
<ol>
<li><code>p1</code>会在3秒后抛出error。</li>
<li><code>p2</code>会在1秒后改变状态。Resolv的返回值是<code>p1</code>.</li>
<li>由于<code>p2</code>的返回值是一个Promise，导致<code>p2</code>自己的状态无效了，此时<code>p2</code>的状态取决于<code>p1</code>.</li>
<li>所以，后面的then语句，都变成针对p1的了。</li>
<li>又过了<code>2秒</code>，<code>p1</code>变为<code>reject</code>，导致触发<code>catch</code>方法。</li>
</ol>
<h2><a id="3-promise-prototype-then" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Promise.prototype.then()</h2>
<p><strong>then方法是定义在原型对象Promise.prototype上的。</strong>
作用：为Promise对象添加状态改变时的回调函数。第一个是Resolved，第二个是Rejected。
then方法返回的是一个新的Promise对象，不是之前的实例。因此 then方法后面还可以再写一个then方法,即链式调用。</p>
<pre><code class="language-JavaScript">getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre>
<p>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<pre><code class="language-JavaScript">getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;Resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;Rejected: &quot;, err);
});
</code></pre>
<p>第一个then函数返回的是一个新的Promise对象。于是才能继续调用then方法。
第二个then方法指定的回调函数，就会等待这个Promise对象状态发生变化，resolv会调用funcA,reject会调用funcB.</p>
<p>下面👇是箭头函数的实现，会更简洁：</p>
<pre><code class="language-JavaScript">getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;Resolved: &quot;, comments),
  err =&gt; console.log(&quot;Rejected: &quot;, err)
);
</code></pre>
<h2><a id="4-promise-prototype-catch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Promise.prototype.catch()</h2>
<h3><a id="promise-prototype-catch%E6%96%B9%E6%B3%95%E6%98%AF-then-null-rejection%E7%9A%84%E5%88%AB%E5%90%8D%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数</h3>
<p><strong>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数.</strong></p>
<pre><code class="language-JavaScript">getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
</code></pre>
<p>getJSON()方法返回的是一个Promise对象。如果resolv，会调用then方法；如果reject则会调用catch方法。</p>
<h3><a id="then%E6%96%B9%E6%B3%95%E6%8C%87%E5%AE%9A%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%90%E8%A1%8C%E4%B8%AD%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8C%E4%B9%9F%E4%BC%9A%E8%A2%ABcatch%E6%96%B9%E6%B3%95%E6%8D%95%E8%8E%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</h3>
<p><strong>另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</strong></p>
<pre><code class="language-JavaScript">p.then((val) =&gt; console.log('fulfilled:', val))
  .catch((err) =&gt; console.log('rejected', err));

// 等同于
p.then((val) =&gt; console.log('fulfilled:', val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>
<pre><code class="language-plain_text">var promise = new Promise(function(resolve, reject) {
  throw new Error('test');
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
</code></pre>
<p>Promise对象Resolved，但是Resolved指定的方法跑出错误。
Promise对象catch方法能捕获跑出的error。</p>
<h3><a id="reject%E6%96%B9%E6%B3%95%E7%AD%89%E5%90%8C%E4%BA%8E%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reject方法等同于抛出错误</h3>
<p>上面的写法跟下面的两种写法是一样的：</p>
<pre><code class="language-plain_text">// 写法一
var promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二
var promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
</code></pre>
<p><strong>由此可见：reject方法等同于抛出错误。</strong></p>
<h3><a id="resolve%E4%B9%8B%E5%90%8E%E5%9C%A8%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8Ccatch%E6%98%AF%E6%8D%95%E8%8E%B7%E4%B8%8D%E5%88%B0%E7%9A%84%E4%B8%8D%E5%88%B0%E7%9A%84%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>resolve之后在抛出错误，catch是捕获不到的不到的。</h3>
<pre><code class="language-plain_text">var promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre>
<p><strong>resolve之后在抛出错误，catch是捕获不到的不到的。</strong></p>
<h3><a id="promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%85%B7%E6%9C%89%E2%80%9C%E5%86%92%E6%B3%A1%E2%80%9D%E6%80%A7%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 对象的错误具有“冒泡”性质</h3>
<p><strong>Promise 对象的错误具有“冒泡”性质,会一直向后传递，直到被捕获为止 ------ 错误总是会被下一个catch语句捕获</strong></p>
<blockquote>
<p>举个栗子：就像是Y染色体上受环境触发的遗传疾病，会不断的遗传给男性后代，任意一个男性都会被特殊的环境触发。</p>
</blockquote>
<pre><code class="language-plain_text">getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre>
<p>上述代码中有三个Promise，第一个由getJSON产生，后两个由then产生。他们之中的任何一个抛出错误，都会被catch捕获。</p>
<p>一般来讲，尽量不要定义Promise的reject状态的回调函数，最好总是使用catch函数，因为catch函数不仅能捕获到reject状态，还能捕获到resolve状态指定方法下抛出的异常。</p>
<h3><a id="promise%E5%AF%B9%E8%B1%A1%E6%8A%9B%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8D%E4%BC%9A%E4%BC%A0%E9%80%92%E5%88%B0%E5%A4%96%E5%B1%82%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise对象抛出的错误不会传递到外层代码</h3>
<p>如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应，这一点上跟传统的try/catch代码块不同的。</p>
<pre><code class="language-plain_text">process.on('unhandledRejection', function (err, p) {
  console.error(err.stack)
});
</code></pre>
<p>时间的监听函数‘unhandledRejection’,有两个参数：
第一个是错误对象
第二个是报错的Promise实例</p>
<p>catch方法返回的也是一个Promise实例，所以后面还是可以无限的调用then方法。
如果catch函数在几个then中间，二执行过程中都没有reject状态，那么会跳过这个中间的catch方法。</p>
<h3><a id="catch%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B9%9F%E8%83%BD%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>catch方法中也能抛出错误</h3>
<pre><code class="language-plain_text">var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log('oh no', error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).then(function() {
  console.log('carry on');
});
// oh no [ReferenceError: x is not defined]
</code></pre>
<p>如上：catch方法指定的函数依旧是可以抛出Error的，但是因为后面没有继续跟进catch方法，所以并没有被捕获。</p>
<h2><a id="5-promise-all" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. Promise.all()</h2>
<p><strong>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</strong></p>
<pre><code class="language-plain_text">var p = Promise.all([p1, p2, p3]);
</code></pre>
<p>Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。
（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况:</p>
<ul>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数</li>
</ul>
<p><strong>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</strong></p>
<pre><code class="language-plain_text">const p1 = new Promise((resolve, reject) =&gt; {
  resolve('hello');
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error('报错了');
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>p1会resolved，p2首先会rejected.
p2有自己的catch方法，并且执行了，那么就会返回一个新的Promise，并且这个Promise的状态会变成Resolved。
所以：Promise.all()的catch方法并不能捕获到这个error。
p2没有自己的catch方法，所以会调用Promise.all()的catch方法。</p>
<h2><a id="6-promise-race" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. Promise.race()</h2>
<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<pre><code class="language-plain_text">var p = Promise.race([p1, p2, p3]);
</code></pre>
<p>p1/p2/p3中只要有一个率先改变状态，p的状态就会随着改变。那个率先改变状态的实例的返回值，就会传递给p的回调函数。</p>
<pre><code class="language-plain_text">const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error('request timeout')), 5000)
  })
]);
p.then(response =&gt; console.log(response));
p.catch(error =&gt; console.log(error));
</code></pre>
<p>5秒内无法返回请求结果，变量p的状态就会变为reject。这也算是竞速的一种应用场景。</p>
<h2><a id="7-promise-resolve" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. Promise.resolve()</h2>
<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用.</p>
<pre><code class="language-plain_text">var jsPromise = Promise.resolve($.ajax('/whatever.json'));
</code></pre>
<p>等价于下面的说法：</p>
<pre><code class="language-plain_text">Promise.resolve('foo')
// 等价于
new Promise(resolve =&gt; resolve('foo'))
</code></pre>
<p>Promise 的第一个参数是一个箭头函数，函数的传入参数是resolve（函数），函数体就是调用传入的函数resolve，resolve调用的时候，也需要一个参数，此时这个参数就是咱们需要转变成Promise对象的那个参数。</p>
<p>Promise.resolve的参数有四种情况：</p>
<ol>
<li>参数是一个Promise实例</li>
<li>参数是一个thenable对象（有then方法的实例）</li>
<li>参数是不具备then方法d的对象应该</li>
<li>不带参数，返回一个Resolved的返回状态。</li>
</ol>
<h2><a id="8%E3%80%81promise-reject%E5%90%8C%E4%B8%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8、Promise.reject()   同上</h2>
<h2><a id="9%E3%80%81%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E9%99%84%E5%8A%A0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9、两个常用附加方法</h2>
<h3><a id="done" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>done()</h3>
<p>Promise的错误并不会冒泡到全局，所以我们可以提供一个done方法总是处于会吊链的尾端。</p>
<pre><code class="language-plain_text">asyncFunc()
  .then(f1)
  .catch(r1)
  .then(f2)
  .done();
</code></pre>
<p>done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出.</p>
<h3><a id="finally" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>finally()</h3>
<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<pre><code class="language-plain_text">Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre>
<h3><a id="promis-try" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promis.try()</h3>
<pre><code class="language-plain_text">try {
  database.users.get({id: userId})
  .then(...)
  .catch(...)
} catch (e) {
  // ...
}
</code></pre>
<pre><code class="language-plain_text">Promise.try(database.users.get({id: userId}))
  .then(...)
  .catch(...)
</code></pre>
<p>Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（Array）]]></title>
    <link href="http://kaelinda.top/15137645005542.html"/>
    
    <updated>2017-12-20T18:08:20+08:00</updated>
    <id>http://kaelinda.top/15137645005542.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="array" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>array</h2>
<ol>
<li>
<p>Array.from
将类似数组的对象（array-like object）和可遍历（iterable）的对象 转换为数组。</p>
<ul>
<li>类数组：有 length属性的对象</li>
<li>可遍历：包含Set Map.</li>
</ul>
</li>
<li>
<p>Array.of
该方法用于将一组值，转换为数组。</p>
</li>
</ol>
<span id="more"></span><!-- more -->
<ol start="3">
<li>
<p>copyWithin
在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
</li>
<li>
<p>数组实例的find()和findIndex()
用于找出第一个符合条件的数组成员。
用于找出第一个符合条件的数组成员的位置。</p>
</li>
<li>
<p>fill
方法使用给定值，填充一个数组。
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c'];// 左闭右开</p>
</li>
<li>
<p>数组实例的entries()，keys()和values()
keys()是对键名的遍历
values()是对键值的遍历
entries()是对键值对的遍历</p>
</li>
<li>
<p>Array.prototype.includes方法
返回一个布尔值，表示某个数组是否包含给定的值。
[1, 2, 3].includes(3, -1); // true
3:将要搜索的item
-1：搜索的起始位置</p>
</li>
<li>
<p>数组的空位
数组的空位指，数组的某一个位置没有任何值。</p>
</li>
</ol>
<p>空位不是undefined，undefined是有值的。
空位是没有任何值。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（常量&&变量）]]></title>
    <link href="http://kaelinda.top/15137627946753.html"/>
    
    <updated>2017-12-20T17:39:54+08:00</updated>
    <id>http://kaelinda.top/15137627946753.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量&amp;&amp;常量</h2>
<h3><a id="%E6%96%B0%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新特性</h3>
<ol>
<li>
<p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
</li>
<li>
<p>变量提升：var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined；为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
</li>
<li>
<p>暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”；</p>
</li>
</ol>
<span id="more"></span><!-- more -->
<pre><code class="language-plain_text">```
var tmp = 123;

if (true) {
tmp = 'abc'; // ReferenceError  死区
let tmp;
}
```

&gt; let不允许在相同作用域内，重复声明同一个变量。
</code></pre>
<h3><a id="%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>块级作用域</h3>
<ul>
<li>内层作用域可以定义外层作用域的同名变量。</li>
<li>内部作用域  重名变量  不会影响，</li>
<li>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数（ES5不允许）。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<blockquote>
<p>块级作用域是一个语句，将多个操作封装在一起，没有返回值。
在块级作用域之前加上do，使它变为do表达式。会得到整个块级作用域的返回值</p>
</blockquote>
<h3><a id="const" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>const:</h3>
<ul>
<li>
<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
</li>
<li>
<p>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
</li>
<li>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
</li>
<li>
<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
</li>
<li>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</p>
</li>
<li>
<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
</li>
<li>
<p>如果真的想将对象冻结，应该使用Object.freeze方法</p>
</li>
</ul>
<pre><code class="language-JavaScript">//冻结对象属性：
var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
</code></pre>
<h3><a id="%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量声明：</h3>
<blockquote>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法</p>
</blockquote>
<ul>
<li>顶层对象的属性：
ES5中 顶层对象的属性  和 全局变量是一回事儿；全局变量是静态创建，而对象属性是动态创建的；不合理。
ES6中 var function 声明的全局变量 依然是顶层对象的属性；但是 let const class声明的全局变量 不属于顶层对象的属性。</li>
</ul>
<!-- more -->
<ul>
<li>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<pre><code class="language-JavaScript">// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &amp;&amp;
      typeof require === 'function' &amp;&amp;
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
</code></pre>
<p>// ES6模块的写法
import getGlobal from 'system.global';
const global = getGlobal();</p>

]]></content>
  </entry>
  
</feed>
