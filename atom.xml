<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Kaelinda]]></title>
  <link href="http://kaelinda.top/atom.xml" rel="self"/>
  <link href="http://kaelinda.top/"/>
  <updated>2021-10-12T11:05:20+08:00</updated>
  <id>http://kaelinda.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[网络是怎样连接的]]></title>
    <link href="http://kaelinda.top/15341646765442.html"/>
    
    <updated>2018-08-13T20:51:16+08:00</updated>
    <id>http://kaelinda.top/15341646765442.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E7%94%9F%E6%88%90http%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成HTTP请求信息</h2>
<p>URL种类：<code>http:</code> <code>ftp:</code> <code>file:</code> <code>mailto:</code> <code>news:</code></p>
<p>URL组成：协议 + 用户名(可省略) + 密码(省略) + 服务器域名 + 端口号(可省略) + 文件路径名</p>
<p><figure><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fu8d5d2w7jj313e19atf8.jpg" alt="" /></figure></p>
<h3><a id="%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络请求</h3>
<p><figure><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fu8fexsc00j313a10ewp6.jpg" alt="" /></figure></p>
<h3><a id="http" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP</h3>
<ul>
<li><code>URI</code>：Uniform Resource Identifier，统一资源标识符</li>
<li><code>CGI</code>：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI</li>
</ul>
<h3><a id="dns%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS服务器</h3>
<p>DNS查询服务包含下面三部分：</p>
<ul>
<li><code>域名</code>：服务器、邮件服务器(邮件地址中 @ 后面的部分)的名称</li>
<li><code>Class</code>：在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而 Class 就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 IN</li>
<li><code>记录类型</code>:表示域名对应何种类型的记录。例如，当类型为 A 时，表示域名 对应的是 IP 地址;当类型为 MX 时，表示域名对应的是邮件服务 器。对于不同的记录类型，服务器向客户端返回的信息也会不同</li>
</ul>
<p><figure><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fubcsxb3lzj318812ualm.jpg" alt="DNS服务器的基本工作" /><figcaption>DNS服务器的基本工作<figcaption></figure></p>
<p><strong>敲黑板，划重点！！！</strong></p>
<blockquote>
<p>上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意 一个域的 DNS 服务器；
根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中，任何 DNS 服务器就都可 以找到并访问根域 DNS 服务器了。</p>
</blockquote>
<p>协议栈传输数据：</p>
<ol>
<li>服务器一方创建套接字，等待客户端向该套接字连接管道 (创建套接字阶段)</li>
<li>客户端创建一个套接字，然后从该套接字伸出管道去连接服务端的套接字 (创建套接字阶段 、连接套接字阶段)</li>
<li>客户端套接字 和 服务端套接字建立连接以后就可以传输网络数据了（数字信息 digital data）(通信阶段)</li>
<li>断开通道、删除套接字 (断开阶段)</li>
</ol>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fup9h6snmhj316s0zg7ah.jpg" alt="" /></figure></p>
<ul>
<li>描述符:应用程序用来识别套接字的机制</li>
<li>IP 地址和端口号:客户端和服务器之间用来识别对方套接字的机制
<figure><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fupfvmg5jwj31j40x60xr.jpg" alt="" /></figure></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从零开始学习使用 vuex]]></title>
    <link href="http://kaelinda.top/15168925544178.html"/>
    
    <updated>2018-01-25T23:02:34+08:00</updated>
    <id>http://kaelinda.top/15168925544178.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<blockquote>
<p>本文是建立在，对vuex理论有一定理解的基础上写的。
因为官方文档的写法是 针对 有一定的vue开发经验 和 JavaScript 有一定理解的开发者看的，对于小白级别的我来说，理解起来有一定困难。所以，唯一想我一向的小白想尽快上手vuex....</p>
</blockquote>
<p><a href="https://vuex.vuejs.org/zh-cn/installation.html">详情请参考vuex官方文档</a></p>
<h2><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h2>
<h3><a id="%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BDcdn%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接下载 CDN 安装</h3>
<p>CDN 链接地址：<code>https://unpkg.com/vuex</code>
指定到固定版本：<code>https://unpkg.com/vuex@2.0.0</code></p>
<pre><code class="language-plain_text">&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3><a id="npm%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%81%E7%AE%80%E5%8D%95%E5%BF%AB%E6%8D%B7%EF%BC%8C%E4%BE%BF%E4%BA%8E%E7%AE%A1%E7%90%86%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>npm 方式安装 （推荐！简单快捷，便于管理）</h3>
<p><code>npm install -save vuex</code></p>
<h3><a id="yar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>yar</h3>
<p><code>yarn add vuex</code></p>
<h3><a id="%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自己构建</h3>
<pre><code class="language-bash">git clone https://github.com/vuejs/vuex.git node_modules/vuex
cd node_modules/vuex
npm install
npm run build
</code></pre>
<h2><a id="%E5%AF%BC%E5%85%A5vue%E5%B7%A5%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导入vue工程中使用</h2>
<ul>
<li>main.js 入口文件</li>
</ul>
<blockquote>
<p>按照如下方式导入，工程就可以使用vuex的环境了</p>
</blockquote>
<pre><code class="language-JavaScript">// 导入vuex头文件
import Vuex from 'vuex'
// 这里表示全局导入vuex
Vue.use(Vuex)
// 这里是我自定义的store文件 导出store对象
import store from '@/study/vuexStudy/store/store.js'
</code></pre>
<blockquote>
<p>入口组件<App/>中，绑定store</p>
</blockquote>
<pre><code class="language-plain_text">new Vue({
  el: '#app',
  template: '&lt;App/&gt;',
  components: { App },
  store
})
</code></pre>
<p>到这里 算是万里长征走了第一步。</p>
<h3><a id="%E5%88%9B%E5%BB%BAstore%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Store对象</h3>
<h4><a id="store%E7%9A%84%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>store 的结构:</h4>
<pre><code class="language-JavaScript">export const store = new Vuex.Store({

  // ------state:状态值存储,这里可以存储n个状态的值
  state: {count: '1'},
  
  // ------getter:store中定义的getters可以认为是store的计算属性
  // getters接收state作为其第一个参数
  getters: {
    done (state) {
      return state.count + 5
    }
  },
  
  // ------mutations:状态值的改变，操作状态值
  // $store.commit(mutationsName, params)是更改状态值的唯一方法
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  },

  // ------actions:可以认为是包装了mutations的function 需要用 dispatch(actionName) 的方式去派发
  actions: {
    add (context) {
      context.commit('increment')
    },
    addAsync (context) {
      // 延时1秒
      setTimeout(() =&gt; {
        context.commit('increment')
      }, 1000)
    }
  },
  // store可以合并几个子store，以此来进行项目的模块化
  modules: {
    a: moduleA,
    b: moduleB
  }
})
</code></pre>
<h4><a id="%E7%BC%96%E8%BE%91%E5%AE%9A%E4%B9%89store%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编辑定义store实体对象：</h4>
<ul>
<li>store.js文件中</li>
</ul>
<blockquote>
<p>这里为了便于抽离 我们外部声明城对象实体后嵌入绑定到store</p>
</blockquote>
<ol>
<li>
<p>创建一个store对象</p>
<pre><code class="language-JavaScript">export default const store = new Vuex.Store({
  state,//绑定之前创建的state对象到store中
  mutations,
  getters,
  actions,
  modules
})
</code></pre>
</li>
<li>
<p>定义一个状态对象 <code>state</code>（实体）</p>
<pre><code class="language-JavaScript">const state = {
  count: 0,
  state1: 1,
  state2: 2,
  state3: 3
}
</code></pre>
</li>
<li>
<p>定义getters对象</p>
<pre><code class="language-plain_text">const getters = {
  done (state) {
    return state.count + 5
  },
  getState1: function (state) {
    return state.state3
  },
  // ES6简写
  getState2: state =&gt;  state.state2
}
</code></pre>
</li>
<li>
<p>.vue 文件中直接获取state值</p>
<p>首先导入辅助函数：</p>
<pre><code class="language-plain_text">import { 
    mapState, 
    mapGetters, 
    mapMutations, 
    mapActions 
    } from 'vuex'
</code></pre>
<ul>
<li>第一种方式：绑定到组件属性中，直接获取 （一般不用这个，绑定到computed中是最合适的）<code>$store.state.count</code>并使用</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    }
}
</code></pre>
<ul>
<li>第二种方式： 绑定到计算属性中（适合对store中的原始状态值进行一定处理的情况）</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        }
    }
}
</code></pre>
<ul>
<li>第三种方式：mapState辅助函数绑定状态state值到组件计算属性中</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
    }
}
</code></pre>
<ul>
<li>第四种方式：使用store中绑定的getters进行获取</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
        testComputedGettersCount2: funtion () {
            return this.$store.getters.done
        }
    }
}
</code></pre>
<ul>
<li>第五种方式： 借助mapGetters辅助函数绑定getters到vue的计算属性中</li>
</ul>
<pre><code class="language-JavaScript">export default {
    data() {
        return {
          testCount: this.$store.state.count
        }
    },
    computed:{
        testComputedCount1: function () {
            return this.$store.state.count + 22
        },
        ...mapState({
            count: state =&gt; state.count,
            mapState1: state =&gt; state.state1,
            mapState2: state =&gt; state.state2
        }),
        testComputedGettersCount2: funtion () {
            return this.$store.getters.done
        },
        
        //直接绑定方法数组的方式
        ...mapGetters([
            'getState1',
            'getState2',
            'getState3'
        ]),
        
        //重命名对象绑定方式
        ...mapGetters({
          mapGetterState1: 'getState1',
          mapGetterState3: 'getState3'
        }),
    }
}
</code></pre>
</li>
<li>
<p>触发动作行为改变状态值</p>
<blockquote>
<p>方式一：$store.commit('mutationsName')</p>
</blockquote>
<blockquote>
<p>方式二：$store.dispatch('actionsName')</p>
</blockquote>
<p>store.js文件中：</p>
<ul>
<li>初始化 mutations 和 actions (相当于是methods)</li>
</ul>
<pre><code class="language-plain_text">const mutations = {
    increment (state) {
        // 变更状态
        state.count = state.count * 5
    }
}
</code></pre>
<pre><code class="language-plain_text">import {action4} from '@/path/actions.js'
const actions = {
    // 同步方法
    add: function (context) {
        context.commit('increment')
    },
    // 延时操作 用于网络请求啊啥的
    addAsync (context) {
        // 延时1秒
        setTimeout(() =&gt; {
            context.commit('increment')
        }, 1000)
    },
    // 简写方式
    action2 (context) {
        context.commit('increment')
    },
    // 抽离到单独文件中，在导进封装好的变量来直接使用即可（导进来的目的是为了接收第一个参数：state），不绑定到store，需要手动传入store对象
    action4: action4,
}
</code></pre>
</li>
</ol>
<ul>
<li>
<p>绑定action 和 mutations 到 methods，然后 调用就行了</p>
<pre><code class="language-plain_text">export default {
    methods: {
        // 数组形式直接载入
        ...mapActions([
            'add'
        ]),
        // 重命名形式 
        ...mapActions({
            add: 'add',
            addAsync: 'addAsync',
            action4: 'action4'
        }),
        // 同上
        ...mapMutations([
            'increment'
        ]),
        ...mapMutations({
            incrementMutation: 'increment'
        })
    }
}
</code></pre>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给安卓项目添加启动图]]></title>
    <link href="http://kaelinda.top/15151216159291.html"/>
    
    <updated>2018-01-05T11:06:55+08:00</updated>
    <id>http://kaelinda.top/15151216159291.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h1><a id="react-native-splash-screen" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>react-native-splash-screen</h1>
<p>给安卓项目添加启动图</p>
<h2><a id="react-native-splash-screen%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>react-native-splash-screen 基本配置</h2>
<ul>
<li>安装插件：<code>npm install react-native-splash-screen --save</code></li>
<li>关联项目：<code>react-native link react-native-splash-screen</code> or <code>rnpm link react-native-splash-screen</code></li>
</ul>
<blockquote>
<p>link 之后，安卓项目中会自动添加头文件 以及部分代码，为保证项目顺利运行，还请确认下面代码是否已经完善。</p>
</blockquote>
<ul>
<li>
<p>确保 <code>android/settings.gradle</code>文件夹已经有下面代码</p>
<pre><code class="language-JavaScript"></code></pre>
</li>
</ul>
<p>include ':react-native-splash-screen'<br />
project(':react-native-splash-screen').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-splash-screen/android')</p>
<pre><code class="language-plain_text">* android/app/build.gradle 文件中 添加依赖 `react-native-splash-screen`

    ```
...
dependencies {
    ...
    compile project(':react-native-splash-screen')
}
</code></pre>
<span id="more"></span><!-- more -->
<ul>
<li>更新 <code>MainApplication.java</code> 文件</li>
</ul>
<pre><code class="language-plain_text">// react-native-splash-screen &gt;= 0.3.1
import org.devio.rn.splashscreen.SplashScreenReactPackage;
// react-native-splash-screen &lt; 0.3.1
import com.cboy.rn.splashscreen.SplashScreenReactPackage;

public class MainApplication extends Application implements ReactApplication {

    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
        protected boolean getUseDeveloperSupport() {
            return BuildConfig.DEBUG;
        }

        @Override
        protected List&lt;ReactPackage&gt; getPackages() {
            return Arrays.&lt;ReactPackage&gt;asList(
                    new MainReactPackage(),
            new SplashScreenReactPackage()  //here
            );
        }
    };

    @Override
    public ReactNativeHost getReactNativeHost() {
        return mReactNativeHost;
    }
}
</code></pre>
<h2><a id="%E5%87%86%E5%A4%87%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%92%8C%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>准备添加代码和文件配置</h2>
<ul>
<li><code>app/src/main/res/layout</code> 文件夹下 添加 <code>launch_screen.xml</code> 并copy如下代码：</li>
</ul>
<pre><code class="language-plain_text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@drawable/launch_screen&quot;&gt;
&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li>
<p>创建文件夹 <code>drawable-xhdpi</code>、 <code>drawable-xxhdpi</code>（暂时先创建这两个就够了），将准备好的启动图 命名为 <code>launch_screen.png</code> 分别放入创建好的文件夹</p>
</li>
<li>
<p>白屏问题，设置透明背景：<code>android/app/src/main/res/values/styles.xml</code> 文件夹下 添加 <code>&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</code></p>
<pre><code class="language-plain_text"></code></pre>
</li>
</ul>
<resources>
    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <!-- Customize your theme here. -->
        <!--设置透明背景-->
        <item name="android:windowIsTranslucent">true</item>
    </style>
</resources>
```
<ul>
<li>
<p><code>android/app/src/main/res/values/colors.xml</code> 文件夹下，添加如下：</p>
<pre><code class="language-plain_text"></code></pre>
</li>
</ul>
<?xml version="1.0" encoding="utf-8"?> <resources> <color name="primary_dark">#660B0B0B</color> </resources>
<pre><code class="language-plain_text">
* 适当的时刻 隐藏启动图  可以是在视图挂载完毕，可以是网络请求结束之后


</code></pre>
<p>import SplashScreen from 'react-native-splash-screen'
componentDidMount() {
SplashScreen.hide();
}</p>
<pre><code class="language-plain_text">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rect-Native 之 Promise 深入浅出从入门到精通]]></title>
    <link href="http://kaelinda.top/15139057022845.html"/>
    
    <updated>2017-12-22T09:21:42+08:00</updated>
    <id>http://kaelinda.top/15139057022845.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念理解</h2>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fhp9dw6vxpj307406ewek.jpg" alt="icon" title="React icon" /><figcaption>icon<figcaption></figure></p>
<blockquote>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
</blockquote>
<span id="more"></span><!-- more -->
<h3><a id="promise%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 状态</h3>
<ul>
<li>Pending 进行中</li>
<li>Resolved 已完成 又称Fulfilled</li>
<li>Rejected 已失败</li>
</ul>
<h3><a id="promise%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 特点</h3>
<ul>
<li>对象的状态不受外部因素影响。Promise对象代表的是一个异步操作，只有异步操作的结果能决定Promise的状态，任何其他操作都不能决定其状态。</li>
<li>一旦Promise有了结果状态就不会再变。<code>Pending==&gt;Resolved</code>,或者<code>Pending==&gt;Rejected</code></li>
</ul>
<h3><a id="promise%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 缺点</h3>
<p>Promise的缺点是：一旦建立就会立即执行，无法中途取消。</p>
<h2><a id="promise%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 基本用法</h2>
<pre><code class="language-JavaScript">var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
</code></pre>
<p>Promise对象接受一个参数，这个参数是一个函数体。
这个函数有两个参数：一个是resolve，一个是reject。这两个参数是Promise自动提供，不需要使用者传值。</p>
<ul>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
Promise实例生成后，可以用then分别指定Resolved和Rejected的回调函数。</li>
</ul>
<pre><code class="language-JavaScript">promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre>
<p>then方法会接受两个参数：</p>
<ul>
<li>第一个函数，Promise状态变更为Resolved时调用。</li>
<li>第二个函数，Promise状态变为Rejected时调用。可选的，可以不提供。</li>
</ul>
<p>下面是异步加载图片的例子：</p>
<pre><code class="language-JavaScript">function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    var image = new Image();

    image.onload = function() {
      resolve(image);
    };

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };

    image.src = url;
  });
}
</code></pre>
<p>下面是Promise实现的Ajax操作的例子：</p>
<pre><code class="language-JavaScript">var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });

  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
</code></pre>
<p><strong>注意：在getJSON内部，resolve函数和reject函数调用时，都带有参数！！</strong><br />
如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。</p>
<ul>
<li>reject函数的参数通常是Error对象的实例，表示抛出的错误</li>
<li>resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作</li>
</ul>
<pre><code class="language-JavaScript">var p1 = new Promise(function (resolve, reject) {
  // ...
});

var p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>
<p>上面👆，<code>p1</code>、<code>p2</code> 都是Promise，但是<code>p2</code>的resolve把<code>p1</code>作为返回值参数传出去了，即一个异步操作的返回结果是另一个异步操作。（类似于iOS开发中的自动布局库 <code>Masonry</code>,可以无限点语法取到对象）。<br />
<strong>注意：此时，p1的状态会传递p2.如果p1是Pending状态,那么p2会等待p1的结果。如果p1是Reject或者Resolve状态，那么p2的回调函数将会立即执行。</strong></p>
<p><strong>再看:</strong></p>
<pre><code class="language-JavaScript">var p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000)
})

var p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 1000)
})

p2.then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre>
<ol>
<li><code>p1</code>会在3秒后抛出error。</li>
<li><code>p2</code>会在1秒后改变状态。Resolv的返回值是<code>p1</code>.</li>
<li>由于<code>p2</code>的返回值是一个Promise，导致<code>p2</code>自己的状态无效了，此时<code>p2</code>的状态取决于<code>p1</code>.</li>
<li>所以，后面的then语句，都变成针对p1的了。</li>
<li>又过了<code>2秒</code>，<code>p1</code>变为<code>reject</code>，导致触发<code>catch</code>方法。</li>
</ol>
<h2><a id="3-promise-prototype-then" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Promise.prototype.then()</h2>
<p><strong>then方法是定义在原型对象Promise.prototype上的。</strong>
作用：为Promise对象添加状态改变时的回调函数。第一个是Resolved，第二个是Rejected。
then方法返回的是一个新的Promise对象，不是之前的实例。因此 then方法后面还可以再写一个then方法,即链式调用。</p>
<pre><code class="language-JavaScript">getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre>
<p>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<pre><code class="language-JavaScript">getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;Resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;Rejected: &quot;, err);
});
</code></pre>
<p>第一个then函数返回的是一个新的Promise对象。于是才能继续调用then方法。
第二个then方法指定的回调函数，就会等待这个Promise对象状态发生变化，resolv会调用funcA,reject会调用funcB.</p>
<p>下面👇是箭头函数的实现，会更简洁：</p>
<pre><code class="language-JavaScript">getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;Resolved: &quot;, comments),
  err =&gt; console.log(&quot;Rejected: &quot;, err)
);
</code></pre>
<h2><a id="4-promise-prototype-catch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Promise.prototype.catch()</h2>
<h3><a id="promise-prototype-catch%E6%96%B9%E6%B3%95%E6%98%AF-then-null-rejection%E7%9A%84%E5%88%AB%E5%90%8D%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数</h3>
<p><strong>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数.</strong></p>
<pre><code class="language-JavaScript">getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
</code></pre>
<p>getJSON()方法返回的是一个Promise对象。如果resolv，会调用then方法；如果reject则会调用catch方法。</p>
<h3><a id="then%E6%96%B9%E6%B3%95%E6%8C%87%E5%AE%9A%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%90%E8%A1%8C%E4%B8%AD%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8C%E4%B9%9F%E4%BC%9A%E8%A2%ABcatch%E6%96%B9%E6%B3%95%E6%8D%95%E8%8E%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</h3>
<p><strong>另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</strong></p>
<pre><code class="language-JavaScript">p.then((val) =&gt; console.log('fulfilled:', val))
  .catch((err) =&gt; console.log('rejected', err));

// 等同于
p.then((val) =&gt; console.log('fulfilled:', val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>
<pre><code class="language-plain_text">var promise = new Promise(function(resolve, reject) {
  throw new Error('test');
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
</code></pre>
<p>Promise对象Resolved，但是Resolved指定的方法跑出错误。
Promise对象catch方法能捕获跑出的error。</p>
<h3><a id="reject%E6%96%B9%E6%B3%95%E7%AD%89%E5%90%8C%E4%BA%8E%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reject方法等同于抛出错误</h3>
<p>上面的写法跟下面的两种写法是一样的：</p>
<pre><code class="language-plain_text">// 写法一
var promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二
var promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
</code></pre>
<p><strong>由此可见：reject方法等同于抛出错误。</strong></p>
<h3><a id="resolve%E4%B9%8B%E5%90%8E%E5%9C%A8%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8Ccatch%E6%98%AF%E6%8D%95%E8%8E%B7%E4%B8%8D%E5%88%B0%E7%9A%84%E4%B8%8D%E5%88%B0%E7%9A%84%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>resolve之后在抛出错误，catch是捕获不到的不到的。</h3>
<pre><code class="language-plain_text">var promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre>
<p><strong>resolve之后在抛出错误，catch是捕获不到的不到的。</strong></p>
<h3><a id="promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%85%B7%E6%9C%89%E2%80%9C%E5%86%92%E6%B3%A1%E2%80%9D%E6%80%A7%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise 对象的错误具有“冒泡”性质</h3>
<p><strong>Promise 对象的错误具有“冒泡”性质,会一直向后传递，直到被捕获为止 ------ 错误总是会被下一个catch语句捕获</strong></p>
<blockquote>
<p>举个栗子：就像是Y染色体上受环境触发的遗传疾病，会不断的遗传给男性后代，任意一个男性都会被特殊的环境触发。</p>
</blockquote>
<pre><code class="language-plain_text">getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre>
<p>上述代码中有三个Promise，第一个由getJSON产生，后两个由then产生。他们之中的任何一个抛出错误，都会被catch捕获。</p>
<p>一般来讲，尽量不要定义Promise的reject状态的回调函数，最好总是使用catch函数，因为catch函数不仅能捕获到reject状态，还能捕获到resolve状态指定方法下抛出的异常。</p>
<h3><a id="promise%E5%AF%B9%E8%B1%A1%E6%8A%9B%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8D%E4%BC%9A%E4%BC%A0%E9%80%92%E5%88%B0%E5%A4%96%E5%B1%82%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise对象抛出的错误不会传递到外层代码</h3>
<p>如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应，这一点上跟传统的try/catch代码块不同的。</p>
<pre><code class="language-plain_text">process.on('unhandledRejection', function (err, p) {
  console.error(err.stack)
});
</code></pre>
<p>时间的监听函数‘unhandledRejection’,有两个参数：
第一个是错误对象
第二个是报错的Promise实例</p>
<p>catch方法返回的也是一个Promise实例，所以后面还是可以无限的调用then方法。
如果catch函数在几个then中间，二执行过程中都没有reject状态，那么会跳过这个中间的catch方法。</p>
<h3><a id="catch%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B9%9F%E8%83%BD%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>catch方法中也能抛出错误</h3>
<pre><code class="language-plain_text">var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log('oh no', error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).then(function() {
  console.log('carry on');
});
// oh no [ReferenceError: x is not defined]
</code></pre>
<p>如上：catch方法指定的函数依旧是可以抛出Error的，但是因为后面没有继续跟进catch方法，所以并没有被捕获。</p>
<h2><a id="5-promise-all" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. Promise.all()</h2>
<p><strong>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</strong></p>
<pre><code class="language-plain_text">var p = Promise.all([p1, p2, p3]);
</code></pre>
<p>Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。
（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况:</p>
<ul>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数</li>
</ul>
<p><strong>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</strong></p>
<pre><code class="language-plain_text">const p1 = new Promise((resolve, reject) =&gt; {
  resolve('hello');
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error('报错了');
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>p1会resolved，p2首先会rejected.
p2有自己的catch方法，并且执行了，那么就会返回一个新的Promise，并且这个Promise的状态会变成Resolved。
所以：Promise.all()的catch方法并不能捕获到这个error。
p2没有自己的catch方法，所以会调用Promise.all()的catch方法。</p>
<h2><a id="6-promise-race" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. Promise.race()</h2>
<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<pre><code class="language-plain_text">var p = Promise.race([p1, p2, p3]);
</code></pre>
<p>p1/p2/p3中只要有一个率先改变状态，p的状态就会随着改变。那个率先改变状态的实例的返回值，就会传递给p的回调函数。</p>
<pre><code class="language-plain_text">const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error('request timeout')), 5000)
  })
]);
p.then(response =&gt; console.log(response));
p.catch(error =&gt; console.log(error));
</code></pre>
<p>5秒内无法返回请求结果，变量p的状态就会变为reject。这也算是竞速的一种应用场景。</p>
<h2><a id="7-promise-resolve" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. Promise.resolve()</h2>
<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用.</p>
<pre><code class="language-plain_text">var jsPromise = Promise.resolve($.ajax('/whatever.json'));
</code></pre>
<p>等价于下面的说法：</p>
<pre><code class="language-plain_text">Promise.resolve('foo')
// 等价于
new Promise(resolve =&gt; resolve('foo'))
</code></pre>
<p>Promise 的第一个参数是一个箭头函数，函数的传入参数是resolve（函数），函数体就是调用传入的函数resolve，resolve调用的时候，也需要一个参数，此时这个参数就是咱们需要转变成Promise对象的那个参数。</p>
<p>Promise.resolve的参数有四种情况：</p>
<ol>
<li>参数是一个Promise实例</li>
<li>参数是一个thenable对象（有then方法的实例）</li>
<li>参数是不具备then方法d的对象应该</li>
<li>不带参数，返回一个Resolved的返回状态。</li>
</ol>
<h2><a id="8%E3%80%81promise-reject%E5%90%8C%E4%B8%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8、Promise.reject()   同上</h2>
<h2><a id="9%E3%80%81%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E9%99%84%E5%8A%A0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9、两个常用附加方法</h2>
<h3><a id="done" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>done()</h3>
<p>Promise的错误并不会冒泡到全局，所以我们可以提供一个done方法总是处于会吊链的尾端。</p>
<pre><code class="language-plain_text">asyncFunc()
  .then(f1)
  .catch(r1)
  .then(f2)
  .done();
</code></pre>
<p>done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出.</p>
<h3><a id="finally" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>finally()</h3>
<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<pre><code class="language-plain_text">Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre>
<h3><a id="promis-try" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promis.try()</h3>
<pre><code class="language-plain_text">try {
  database.users.get({id: userId})
  .then(...)
  .catch(...)
} catch (e) {
  // ...
}
</code></pre>
<pre><code class="language-plain_text">Promise.try(database.users.get({id: userId}))
  .then(...)
  .catch(...)
</code></pre>
<p>Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（Array）]]></title>
    <link href="http://kaelinda.top/15137645005542.html"/>
    
    <updated>2017-12-20T18:08:20+08:00</updated>
    <id>http://kaelinda.top/15137645005542.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="array" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>array</h2>
<ol>
<li>
<p>Array.from
将类似数组的对象（array-like object）和可遍历（iterable）的对象 转换为数组。</p>
<ul>
<li>类数组：有 length属性的对象</li>
<li>可遍历：包含Set Map.</li>
</ul>
</li>
<li>
<p>Array.of
该方法用于将一组值，转换为数组。</p>
</li>
</ol>
<span id="more"></span><!-- more -->
<ol start="3">
<li>
<p>copyWithin
在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
</li>
<li>
<p>数组实例的find()和findIndex()
用于找出第一个符合条件的数组成员。
用于找出第一个符合条件的数组成员的位置。</p>
</li>
<li>
<p>fill
方法使用给定值，填充一个数组。
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c'];// 左闭右开</p>
</li>
<li>
<p>数组实例的entries()，keys()和values()
keys()是对键名的遍历
values()是对键值的遍历
entries()是对键值对的遍历</p>
</li>
<li>
<p>Array.prototype.includes方法
返回一个布尔值，表示某个数组是否包含给定的值。
[1, 2, 3].includes(3, -1); // true
3:将要搜索的item
-1：搜索的起始位置</p>
</li>
<li>
<p>数组的空位
数组的空位指，数组的某一个位置没有任何值。</p>
</li>
</ol>
<p>空位不是undefined，undefined是有值的。
空位是没有任何值。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 笔记（常量&&变量）]]></title>
    <link href="http://kaelinda.top/15137627946753.html"/>
    
    <updated>2017-12-20T17:39:54+08:00</updated>
    <id>http://kaelinda.top/15137627946753.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量&amp;&amp;常量</h2>
<h3><a id="%E6%96%B0%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新特性</h3>
<ol>
<li>
<p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
</li>
<li>
<p>变量提升：var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined；为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
</li>
<li>
<p>暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”；</p>
</li>
</ol>
<span id="more"></span><!-- more -->
<pre><code class="language-plain_text">```
var tmp = 123;

if (true) {
tmp = 'abc'; // ReferenceError  死区
let tmp;
}
```

&gt; let不允许在相同作用域内，重复声明同一个变量。
</code></pre>
<h3><a id="%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>块级作用域</h3>
<ul>
<li>内层作用域可以定义外层作用域的同名变量。</li>
<li>内部作用域  重名变量  不会影响，</li>
<li>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数（ES5不允许）。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<blockquote>
<p>块级作用域是一个语句，将多个操作封装在一起，没有返回值。
在块级作用域之前加上do，使它变为do表达式。会得到整个块级作用域的返回值</p>
</blockquote>
<h3><a id="const" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>const:</h3>
<ul>
<li>
<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
</li>
<li>
<p>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
</li>
<li>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
</li>
<li>
<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
</li>
<li>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</p>
</li>
<li>
<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
</li>
<li>
<p>如果真的想将对象冻结，应该使用Object.freeze方法</p>
</li>
</ul>
<pre><code class="language-JavaScript">//冻结对象属性：
var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
</code></pre>
<h3><a id="%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量声明：</h3>
<blockquote>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法</p>
</blockquote>
<ul>
<li>顶层对象的属性：
ES5中 顶层对象的属性  和 全局变量是一回事儿；全局变量是静态创建，而对象属性是动态创建的；不合理。
ES6中 var function 声明的全局变量 依然是顶层对象的属性；但是 let const class声明的全局变量 不属于顶层对象的属性。</li>
</ul>
<!-- more -->
<ul>
<li>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<pre><code class="language-JavaScript">// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &amp;&amp;
      typeof require === 'function' &amp;&amp;
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
</code></pre>
<p>// ES6模块的写法
import getGlobal from 'system.global';
const global = getGlobal();</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6笔记（解构赋值）]]></title>
    <link href="http://kaelinda.top/15137621729153.html"/>
    
    <updated>2017-12-20T17:29:32+08:00</updated>
    <id>http://kaelinda.top/15137621729153.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解构赋值</h2>
<h3><a id="%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量的解构：</h3>
<ul>
<li>解构赋值允许指定默认值。</li>
<li>解构赋值必须保证赋值方  被赋值方类型一直  但Item允许有遗漏或者多出。</li>
<li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li>
</ul>
<pre><code class="language-plain_text">let [x = 1, y = x] = [];     // x=1; y=1
let [x = y, y = 1] = [];     // ReferenceError
</code></pre>
<span id="more"></span><!-- more -->
<h3><a id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象的 解构赋值：</h3>
<ul>
<li>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；</p>
</li>
<li>
<p>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值
（数据库、序列化）</p>
</li>
<li>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者；前者是key,后者才是变量！</p>
</li>
</ul>
<blockquote>
<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>
</blockquote>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串的解构赋值</h3>
<blockquote>
<p>字符串也可以解构赋值。
这是因为此时，字符串被转换成了一个类似数组的对象
类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
</blockquote>
<pre><code class="language-JavaScript">let {length : len} = 'hello';
len // 5

let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<ul>
<li>不能使用圆括号的情况
<ul>
<li>变量声明语句中，不能带有圆括号</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中</li>
</ul>
</li>
<li>可以使用圆括号的情况只有一种：赋值语句的<strong>非模式部分</strong>，可以使用圆括号。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 集成 Redux]]></title>
    <link href="http://kaelinda.top/15115315701641.html"/>
    
    <updated>2017-11-24T21:52:50+08:00</updated>
    <id>http://kaelinda.top/15115315701641.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>课程介绍</h2>
<ul>
<li>Flux/reFlux/Redux</li>
<li>简单/单一状态树</li>
</ul>
<ul>
<li>
<p>react 和 redux 数据流的关系</p>
</li>
<li>
<p>JS、CSS、HTML</p>
</li>
<li>
<p>JSX</p>
</li>
<li>
<p>webpack 构建</p>
</li>
</ul>
<h2><a id="%E6%95%B0%E6%8D%AE%E6%B5%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据流</h2>
<ul>
<li>MVC 状态复杂之后，action会触发事件 并且不可预测</li>
<li>flux: state Tree will send data to view,but view can't send data to state-tree.</li>
<li>Redux :  state 是包含在store中的</li>
</ul>
<span id="more"></span><!-- more -->
<h2><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h2>
<pre><code class="language-plain_text">npm install react
npm install redux react-redux --save
</code></pre>
<h2><a id="%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%EF%BC%88%E9%80%9F%E6%88%90%E7%89%88%E6%9C%AC%EF%BC%89%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速开始（速成版本）：</h2>
<h3><a id="%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心概念</h3>
<ul>
<li><code>action</code> : React行为/变化的描述 是一个对象</li>
<li><code>dispatch</code> : 派发用户行为的一个方法 <code>store</code>的一个属性</li>
<li><code>reducer</code> : 接收<code>action</code>,并进行简单的拼接，其内部是<code>纯函数</code>（到底什么是纯函数请移步百度 ： <a href="https://www.baidu.com/s?wd=%E7%BA%AF%E5%87%BD%E6%95%B0">传送门</a> 、 <a href="http://blog.csdn.net/hongweigg/article/details/44035283">速达传送门</a>）</li>
<li><code>store</code> :存储数据的地方</li>
</ul>
<h3><a id="get-start" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get start:</h3>
<ul>
<li>
<p>step1 : <strong>安装依赖</strong></p>
<pre><code class="language-plain_text">npm install redux react-redux --save
</code></pre>
</li>
<li>
<p>step2 : 创建一个 AppProvider.js 并导出AppProvider组件 ：  <strong>AppProvider 作为APP的入口组件</strong></p>
<pre><code class="language-plain_text">export default AppProvider;
</code></pre>
</li>
<li>
<p>step3 : AppProvider.js 中导入头文件</p>
<pre><code class="language-plain_text">    import { Provider } from 'react-redux';    
    import { createStore } from 'redux';
</code></pre>
</li>
<li>
<p>step4 : 准备AppProvider的包装数据：</p>
<ul>
<li>
<p>创建全局的store用于存储状态,并绑定<strong>reducer</strong></p>
<pre><code class="language-plain_text">const store = createStore(AppReducer)
</code></pre>
</li>
<li>
<p>包装APPProvider：</p>
<pre><code class="language-plain_text">const AppProvider = () =&gt; {
    return (
      //KR-1 包裹一层Provider   之后进入被包裹控件内部 进行关联处理
        &lt;Provider store={store}&gt;
            &lt;RootStack /&gt;
        &lt;/Provider&gt;
    )
};
</code></pre>
</li>
<li>
<p>index.ios.js 文件中注册下 AppProvider对象</p>
<pre><code class="language-plain_text">AppRegistry.registerComponent('XinLiFM', () =&gt; AppProvider);
</code></pre>
</li>
</ul>
</li>
<li>
<p>step5 : <strong>数据绑定</strong> 找到打算有 数据流传递 的对象 AppFind</p>
<ul>
<li>
<p>导入头文件：</p>
<pre><code class="language-plain_text">import { connect } from 'react-redux';
</code></pre>
</li>
<li>
<p>绑定数据：</p>
<pre><code class="language-plain_text">//用来获取更新后的数据   监听数据更新
const mapStateToProps = (state,ownProps) =&gt; {
    console.log(state);
    return {
        testShow: state.find.testShow,
     }
}

//用来派发消息
const mapDispatchToProps = (dispatch,ownProps) =&gt; ({
  changeTabBar: (...args) =&gt; dispatch(showTabBar(...args)),
});

//用来进行数据流  和  控件的绑定关系
export default connect(mapStateToProps,mapDispatchToProps)(AppFind)

</code></pre>
</li>
<li>
<p>派发消息：</p>
</li>
</ul>
<pre><code class="language-plain_text">this.props.changeTabBar(!this.props.testShow)
</code></pre>
<ul>
<li>
<p>消息处理：step4 中绑定的reducer文件中:</p>
<pre><code class="language-plain_text">//1.导入头文件
import { combineReducers } from 'redux';
//2.创建初始化状态
const initialState = { testShow: true};
//3.逻辑处理
</code></pre>
</li>
</ul>
<p>const find = (state = initialState, action) =&gt; {
switch (action.type) {
case 'findshowTabBar':{
return Object.assign({}, state, {
testShow: action.testShow
})
}
default:
return state;</p>
<pre><code class="language-plain_text">      }
  }
  //4.组合所有的逻辑块
  const AppReducer = combineReducers({
      find,
      //如果业务繁多这里可能还有别的模块
  });
  //5.导出
  export default AppReducer;
  ```
</code></pre>
<ul>
<li>
<p>获取更改状态值：</p>
<pre><code class="language-plain_text">//因为上一步的绑定数据  就是将state的状态值 绑定到AppFind的props上，
//所以取值的时候直接从this。props中取即可
var {testShow,isShowTab,showTabBar} = this.props;
&lt;Text 
    style={{fontSize:17,color:testShow?&quot;red&quot;:'rgb(39, 249, 110)'}}&gt;
    {testShow?&quot;我要显示某个东西&quot;:&quot;我要隐藏某个东西&quot;}
&lt;/Text&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：
其实这里最重要的就三步：1. 包装   2、数据绑定 3、数据处理</p>
</blockquote>
<h2><a id="%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础</h2>
<h3><a id="1-action" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. action</h3>
<p>信息的携带者。
<strong>派发消息的几种方式：</strong></p>
<ul>
<li>直接发送：</li>
</ul>
<pre><code class="language-plain_text">dispatch({type:'action_name',index:2});

const myAction = {
  type:'action_name',
  index: 1,
}
dispatch(myAction);
</code></pre>
<ul>
<li>通过Action的创建函数发送：</li>
</ul>
<pre><code class="language-plain_text">//我们可以把所有的Action封装到一个固定文件 就想CSS文件那样 头文件导入的方式 去引用
const actionFunc = (text) =&gt; {
  return {
    type: 'action_name',
    index: 2,
  }
}

//派发消息时候 直接引用创建函数的返回结果即可
dispatch(actionFunc('test'));
</code></pre>
<ul>
<li>绑定的Action创建函数</li>
</ul>
<pre><code class="language-plain_text">//基本action创建函数
const actionFunc = (text) =&gt; {
  return {
    type: 'action_name',
    index: 2,
  }
}
//绑定派发方法
const boundAction = (test) =&gt; {
  dispatch(actionFunc(test));
}

//使用绑定好的派发函数
boundAction('test');
</code></pre>
<h3><a id="2-reducer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. reducer</h3>
<p>纯函数；</p>
<ul>
<li>
<p>方法结构</p>
<pre><code class="language-plain_text">(previouseState,action) =&gt; newState
</code></pre>
<p>给一个旧的state 和一个action 生成 一个新的 state。</p>
</li>
<li>
<p>基本方法</p>
<pre><code class="language-plain_text">const initialState = { testShow: true};

const home = (state = initialState, action) =&gt; {
  switch (action.type) {
    case 'homeshowTabBar':{

      console.log(&quot;homeshowTabBar：%s&quot;,action.testShow);
    
    //合并状态值
      return Object.assign({}, state, {
        testShow: action.testShow;
      })
    }
    default:
    return state;

  }
}   
</code></pre>
<p>合并state的时候下面的方法也是能达到相同效果的</p>
<pre><code class="language-plain_text">{...state, ...newState} 
</code></pre>
</li>
<li>
<p>拆分合并reducer</p>
<pre><code class="language-plain_text">const home = (state = initialState, action) =&gt; {
    switch (action.type) {
        case 'homeshowTabBar':{
            console.log(&quot;homeshowTabBar：%s&quot;,action.testShow);
            return Object.assign({}, state, {
                testShow: action.testShow
            })
        }
        default:
        return state;
    }
}

const find = (state = initialState, action) =&gt; {
    switch (action.type) {
        case 'findshowTabBar':{
            return Object.assign({}, state, {
            testShow: action.testShow
            })
        }
        default:
        return state;

    }
}

//合并
const AppReducer = combineReducers({
    nav,
    home,
    find,
});
export default AppReducer
</code></pre>
<p><strong>注意上面的写法和下面完全等价!!!</strong>：</p>
<pre><code class="language-plain_text">const AppReducer = (state={}, action) =&gt; {
    return {
        home: home(state.home,action),
        find: find(sate.find,action),
    }
}
</code></pre>
</li>
<li>
<p>减少代码量 自动定义 reducerCreator</p>
<pre><code class="language-plain_text">export const testCreator = myCreatorForReducer([], {
 [ActionTypes.ADD_TODO](state, action) {
 let text = action.text.trim();
 return [...state, text];
 }
})

const myCreatorForReducer = (initialState,handles) =&gt; {

    return (state=initialState,action) =&gt; {
        return handles[action.type](state,action);
    }else {
     return state;
    }

}
</code></pre>
<p>设置不同的Key、调用不同的方法:</p>
<pre><code class="language-plain_text">const reducer = combineReducers({
    a: doSomethingWithA,
    b: processB,
    c: c
})

function reducer(state = {}, action) {
    return {
        a: doSomethingWithA(state.a, action),
        b: processB(state.b, action),
        c: c(state.c, action)
    }
}
</code></pre>
</li>
</ul>
<h3><a id="3-store" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. store</h3>
<ul>
<li>维持应用的 <code>state</code>；</li>
<li>提供 <code>getState()</code> 方法获取 <code>state</code>；</li>
<li>提供 <code>dispatch(action)</code> 方法更新 <code>state</code>；</li>
<li>通过 <code>subscribe(listener)</code> 注册监听器;</li>
<li>通过 <code>subscribe(listener)</code> 返回的函数注销监听器。</li>
</ul>
<pre><code class="language-plain_text">import { createStore } from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
</code></pre>
<blockquote>
<p>后续会更新的................</p>
</blockquote>
<h2><a id="%E9%AB%98%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高级</h2>
<h3><a id="%E5%BC%82%E6%AD%A5action" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>异步action</h3>
<h3><a id="%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E6%B5%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>异步数据流</h3>
<h3><a id="middleware%E4%B8%AD%E9%97%B4%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Middleware 中间件</h3>
<h3><a id="%E6%90%AD%E9%85%8Dreact-router" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>搭配 React Router</h3>
<h2><a id="%E6%8A%80%E5%B7%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>技巧</h2>
<h2><a id="api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SectionListView]]></title>
    <link href="http://kaelinda.top/14948260667614.html"/>
    
    <updated>2017-05-15T13:27:46+08:00</updated>
    <id>http://kaelinda.top/14948260667614.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>属性</h2>
<ol>
<li>ItemSeparatorComponent  <code>{highlighted,leadingItem,leandingSection,section,trailingItem}</code><br />
返回一个行与行之间的分割组件，不会出现在第一行之前和最后一行之后。
<ul>
<li><code>highlighted</code> 当前行（分割线上面👆的Item）是否是高亮状态</li>
<li><code>leadingItem</code> 当前行分配到的数据源</li>
<li><code>leandingSection</code> 目前我也没搞明白啥意思 这里是<code>undefined</code></li>
<li><code>section</code> 当前段分配到的数据源</li>
<li><code>trailingItem</code> 尾段数据</li>
</ul>
</li>
<li>ListEmptyCompone  <code>没有接收参数</code><br />
渲染一个cell为空时的缓冲组件</li>
<li>ListFooterComponent  <code>没有接收参数</code><br />
渲染整个组件的Footer</li>
<li>ListHeaderComponent   <code>没有接收参数</code><br />
渲染整个组件的Header</li>
</ol>
<span id="more"></span><!-- more -->
<ol start="5">
<li>
<p>SectionSeparatorComponent <code>{highlighted,leadingItem,leandingSection,section,trailingItem}</code>
段分割组件</p>
<ul>
<li><code>highlighted</code> 当前行（分割线上面👆的Item）是否是高亮状态</li>
<li><code>leadingItem</code> 当前行分配到的数据源 这里是<code>undefined</code></li>
<li><code>leandingSection</code> 目前我也没搞明白啥意思 这里是<code>undefined</code></li>
<li><code>section</code> 当前段分配到的数据源</li>
<li><code>trailingItem</code> 尾段数据</li>
</ul>
</li>
<li>
<p>extraData<br />
如果有除data以外的数据用在列表中（不论是用在renderItem还是Header或者Footer中），请在此属性中指定。同时此数据在修改时也需要先修改其引用地址（比如先复制到一个新的Object或者数组中），然后再修改其值，否则界面很可能不会刷新。</p>
</li>
</ol>
<blockquote>
<p>文档说的挺乱，总而言之言而总之：sectionList的刷新首先决定于Data，当Data没变化，但是你想强制刷新UI的时候，有个状态控制，那么这个状态控制需要在这里写一下，关联一下，否则你的这个状态不会被关联，UI不会被刷新。</p>
</blockquote>
<ol start="7">
<li>
<p>initialNumToRender<br />
指定一开始渲染的item 数量,预加载item 数</p>
</li>
<li>
<p>keyExtractor <code>(item: ItemT, index: number) =&gt; string</code>
此函数用于为<strong>给定的item</strong>生成一个不重复的key。Key的作用是使React能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。若不指定此函数，则默认抽取item.key作为key值。若item.key也不存在，则使用数组下标。</p>
</li>
<li>
<p>onEndReachedThreshold  <code>number</code><br />
数值。决定当距离内容最底部还有多远时触发onEndReached回调。注意此参数是一个比值而非像素单位。比如，0.5表示距离内容最底部的距离为当前列表可见长度的一半时触发</p>
</li>
<li>
<p>onEndReached  <code>(info: {distanceFromEnd: number}) =&gt; void</code></p>
<p>传入一个对象info，info包含number类型的<code>distanceFromEnd</code>属性。</p>
</li>
<li>
<p>onViewableItemsChanged <code>(info: {viewableItems: Array&lt;ViewToken&gt;, changed: Array&lt;ViewToken&gt;}) =&gt; void</code></p>
<ul>
<li>viewableItems 可是Item对应的数据</li>
<li>changed 改变的数据<br />
可视元素发生变化时调用</li>
</ul>
</li>
<li>
<p>refreshing <code>boolean</code><br />
等待新数据加载时此属性设置为true，列表会显示出正在加载的符号</p>
</li>
<li>
<p>renderItem  <code>(info: {item: Item, index: number}) =&gt; ?React.Element&lt;any&gt; </code><br />
渲染每一个section中的item</p>
<ul>
<li>item 每个item渲染所需数据</li>
<li>index item在其section中的位置索引</li>
</ul>
</li>
<li>
<p>renderSectionHeader?: <code>{section: SectionT}</code>
接收一个对象，这个对象包含<code>section</code>属性，
返回一个组件，用作段头</p>
</li>
<li>
<p>sections <code>ReadOnlyArray&lt;SectionT&gt;</code></p>
<p>传入一个sections数组</p>
<pre><code class="language-plain_text">[
{data:[{name:'nader'},{name:'chris'}],key:'A'},
{data:[{name:'nick'},{name:'amanda'}],key:'B'},
{data:[{name:'nick'},{name:'amanda'}],key:'C'},
{data:[{name:'nick'}],key:'D'},
</code></pre>
</li>
</ol>
<p>]
```</p>
<ol start="16">
<li>stickySectionHeadersEnabled <code>boolean</code></li>
</ol>
<h2><a id="%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法</h2>
<ul>
<li><code>scrollToLocation (params: object) </code> -- {sectionIndex,itemIndex}:代码控制 UI交互跳转到指定位置</li>
<li><code>recordInteraction()</code> 告诉ListView 交互已经发生了</li>
<li><code>flashScrollIndicators()</code>显示指示滚动</li>
</ul>

]]></content>
  </entry>
  
</feed>
